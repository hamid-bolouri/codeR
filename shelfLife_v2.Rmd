---
title: "shelfLife_v2"
author: "hamid.bolouri@alleninstitute.org"
date: "July/7/2019"
output:
  html_document:
    theme: united
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```

### Allocate memory  and use all CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 8)    ### set number of CPUs. Only works in plain R ###
options(future.globals.maxSize = 20 * 1024 ^ 3)

library("future.apply")
library("stats")
```

### Refs

Based on https://www.dropbox.com/s/38h5zccv0b7l9pr/pbmc3k_tutorial.Rmd?dl=1
See also: https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html
`Seurat` object wiki [GitHub Wiki](https://github.com/satijalab/seurat/wiki). 


```{r init}
library(dplyr)
library(Seurat)

# Load the PBMC dataset
setwd("~/__Data")
load("Aggr_Human_Immunology_RTX-850_GRCh38-3.0.0_mat_v3_reads.RData")

# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = mat, project = "pbmcAging", min.cells = 3, min.features = 200)
rm(mat)
gc()

```

```{r}
# Examine a few genes in the first thirty cells
# pbmc.data[c("CD3D","TCL1A","MS4A1"), 1:30]
```

```{r mito, fig.height=7, fig.width=13}
# The [[.]] operator can add columns to object metadata 
pbmc[["percent.mt"]] <- PercentageFeatureSet(object = pbmc, pattern = "^MT-")
hist(unlist(pbmc[["percent.mt"]]), breaks=50, col="skyblue", main="",
     border="white", xlab="Percentage of genes that are mitochondrial") # long tail past 20% MT

IDs <-rownames(pbmc@meta.data)
IDs <- strsplit(IDs, "-")
donors <- unlist(lapply(IDs, function(x) x[2]))
timePoints <- unlist(lapply(IDs, function(x) x[3]))
timePoints[timePoints == "18h"] <- "hr18"
plotPoints <- data.frame(pbmc[["percent.mt"]], TimePoint=timePoints)

# library(beeswarm)
# beeswarm(plotPoints)

library(ggplot2) # , fill=TimePoint
theme_update(text = element_text(size=20))
ggplot(plotPoints, aes(x=TimePoint, y=percent.mt, color=TimePoint)) + 
geom_violin() +
stat_summary(fun.data=mean_sdl, mult=1, 
             geom="pointrange", color=rgb(0,0,0,1)) +
theme(axis.text.x = element_text(size = 20), 
      axis.text.y = element_text(size = 20))

```

```{r qc, fig.height=7, fig.width=13}
# Show QC metrics for the first 5 cells
head(x = pbmc@meta.data, 5)
```

```{r qc2, fig.height=7, fig.width=13}

# Visualize QC metrics as a violin plot
VlnPlot(object = pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3, pt.size = 0)

plot1 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
CombinePlots(plots = list(plot1,plot2))

pbmc <- subset(x = pbmc, subset = nFeature_RNA > 500 & nFeature_RNA < 6000 & percent.mt < 15)
gc()
```

### Normalizing the data

Default is a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression. Normalized values are stored in `pbmc[["RNA"]]@data`.

```{r normalize}
# Not run. See scTransform below.
# pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 1e4)
```

```{r var_features, fig.height=5, fig.width=11}
pbmc <- FindVariableFeatures(object = pbmc,selection.method = 'vst', nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(x = VariableFeatures(object = pbmc), 10)
top500 <- head(x = VariableFeatures(object = pbmc), 500)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(object = pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1 , plot2))
```

### Scaling the data

Counts -> Z-scores for PCA, etc.

```{r regress, fig.height=7, fig.width=11, results='hide'}
# Old Seurat approach to normalization & scaling with individual commands:
# all.genes <- rownames(x = pbmc)

# 'vars.to.regress' filters out bad cells:
# pbmc <- ScaleData(object = pbmc, features = all.genes)
```

However, `sctransform` is the new recommended method and comes with a `vars.to.regress` parameter.

```{r scaling and normalization, results='hide'}
gc()
pbmc <- SCTransform(object = pbmc, verbose = FALSE, vars.to.regress = 'percent.mt', conserve.memory = TRUE)
# Transformed data will be available in the SCT assay, 
# which is set as the default after running sctransform

# names(pbmc) #  "RNA" "SCT" 
normalizedPBMC <- GetAssayData(object = pbmc, assay="SCT", slot = "data")
setwd("~/__Data")
# getwd()
save(normalizedPBMC, file="SeuratNormalizedCounts_GRCh38_filteredMT.RData")
save(pbmc, file="seuratObj_pbmc_shelfLifeHD.RData")
# nonZeros <- as.matrix(normalizedPBMC); nonZeros <- nonZeros[(nonZeros > 0)]
# hist(nonZeros, breaks=10) # nothing above ~5.5, most values between 1 and 2.
```

## Get normalizedPBMC

```{r get_normalizedPBMC}
library("Matrix")
library(dplyr)
library(Seurat)

setwd("~/__Data")
normalizedPBMC <- get(load("SeuratNormalizedCounts_GRCh38_filteredMT.RData"))
PBMC.IDs <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[1]))
 
setwd("~/__Data")
CLs <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(CLs$Barcode, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clusterIDs), ]
CLs$Barcode <- colnames(normalizedPBMC)
colnames(CLs) <- c("ID", "group")
CLs$group<- as.factor(CLs$group)
library(S4Vectors)
CLs <- DataFrame(CLs)

IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")

```

### Pathway analysis

```{r differentialExpression}
setwd("~/__Data"); 

#### Look for genes DE across timepoints
runDE <- function(time1, time2) {
  
   testDE <- function(x) {
     x1 <- x[grep(paste0("-", time1, "h$"), names(x))]
     x2 <- x[grep(paste0("-", time2, "h$"), names(x))]
     x1 <- x1[x1 > 0]
     x2 <- x2[x2 > 0]
     # Consider only clutsers with > 100 cells
     if (length(x1) > 100 & length(x2)>100) {
       wilcox.test(x1, x2)$p.value
     }
   }

   clusterNos = 1:10
   res = NULL; N = 0
   resList = resLabels = list()
   Sys.time()
   for (cl in clusterNos) {
     i.CL <- grep(cl, CLs$group)
     clTbl <- normalizedPBMC[ , i.CL]
   
     stepSize = 1000
     M <- dim(clTbl)[1] - stepSize
     i1 = i2 = 0; res = NULL
     while (i2 < M) {
       i1 <- i2 + 1; i2 <- i2 + stepSize
       res1 <- unlist(future_apply(clTbl[i1:i2, ], 1, FUN = testDE))
       res1 <- res1[res1 < 0.01 & !is.na(res1)]
       res <- c(res, res1)
       # print(i1)
     }
     
     remaining <- (i2+1):(dim(clTbl)[1])
     res2 <- unlist(future_apply(clTbl[remaining, ], 1, FUN = testDE))
     res2 <- res2[res2 < 0.01 & !is.na(res2)]
     res <- c(res, res2)
     if (!is.null(res)) {
        N <- N +1
        resList[[N]] <- res
        resLabels[[N]] <- paste0("cluster", cl)
        print(paste0("cluster ", cl, "  time:", Sys.time()))
     }
   }
   
   # res.adj <- lapply(resList, function(x) p.adjust(x, method="fdr")) 
   # NB. Previous method above only corrected for number of tests KEPT!
   res.adj <- lapply(resList, function(x) x * nrow(clTbl))
   res.adj <- lapply(res.adj, sort)
   names(res.adj) <- unlist(resLabels)
   res.adj <- res.adj[which(unlist(lapply(res.adj, length) > 0))]
   return(res.adj)
}

T1 = 2; T2 = 8
res.adj <- runDE(time1=T1, time2=T2)
setwd("~/__Data")
save(res.adj, file=paste0("shelfLife_HD_DE", T1, "to", T2, "hr_pVals_adjFDR_v2.RData"))
library(erer)
setwd("~/__Data")
write.list(z=res.adj, 
           file=paste0("shelfLife_HD_DE", T1, "to", T2, "hr_pVals_adjFDR_v2.CSV"), 
           row.names=TRUE)


setwd("~/__Data")
DE2.4 <- get(load("shelfLife_HD_DE2to4hr_pVals_adjFDR_v2.RData"))
DE2.6 <- get(load("shelfLife_HD_DE2to6hr_pVals_adjFDR_v2.RData"))
DE2.8 <- get(load("shelfLife_HD_DE2to8hr_pVals_adjFDR_v2.RData"))

# library("VennDiagram")
library("eulerr")

setwd("~/__Plots")
pdf("shelfLife_DE2.4.6.8_Venns.pdf")
par(mfrow = c(2, 3))
for (i in names(DE2.4)) {
  genes2.4 <- names(DE2.4[[i]][which(DE2.4[[i]] < 0.01)])
  genes2.6 <- names(DE2.6[[i]][which(DE2.6[[i]] < 0.01)])
  genes2.8 <- names(DE2.8[[i]][which(DE2.8[[i]] < 0.01)])
  print(plot(euler(list(DE2.4=genes2.4, DE2.6=genes2.6, DE2.8=genes2.8), 
             shape = "ellipse"), quantities = TRUE, main=i,  
       col=c("red", "blue", "green")))
}
dev.off

shared = list()
for (i in names(DE2.4)) {
  genes2.4 <- names(DE2.4[[i]][which(DE2.4[[i]] < 0.01)])
  genes2.6 <- names(DE2.6[[i]][which(DE2.6[[i]] < 0.01)])
  genes2.8 <- names(DE2.8[[i]][which(DE2.8[[i]] < 0.01)])
  shared[[i]] <- intersect(intersect(genes2.4, genes2.6), genes2.8)
}

setwd("~/__Data/")
save(shared, file="sharedGenesPerClusterDE2.4.6.8.RData")

library(pheatmap)
setwd("~/__Data")
avExpList <- get(load("avExpList.RData"))
M <- avExpList[["BRISL4:C6"]]
M <- M[intersect(shared[["cluster6"]], rownames(M)), ]
setwd("~/__Plots")
pdf("shelfLife_HD.BRISL4_DE2.4.6.8.18_cluster6Markers_heatmap.pdf")
pheatmap(M, scale="row", cluster_cols=FALSE)
dev.off()

```

## 

```{r avExpPerDonorPerTimepoint}
clusterNos = 1:10

Sys.time()
avExpList <- list(); indx = 0
for (i in IDs) {
  print(i)
  i.ID <- grep(i, colnames(normalizedPBMC))
  for (cl in clusterNos) {
     i.CL <- grep(cl, CLs$Cluster)
     resMtrx = colID = NULL
     for (h in HRs) {
          i.HR <- grep(h, colnames(normalizedPBMC))
          j <- intersect(intersect(i.ID, i.HR), i.CL)
          if (length(j) > 2) { # skip clusters with few cells in this ID+HR
            resMtrx <- cbind(resMtrx, apply(normalizedPBMC[ , j], 1, median))
            colID <- c(colID, paste0(i, ":", "C", cl, ":", h))
          }
     }
     if (!is.null(resMtrx)) {
       colnames(resMtrx) <- colID
       indx <- indx + 1
       avExpList[[indx]] <- resMtrx
       names(avExpList)[indx] <- paste0(i, ":", "C", cl)
     }
  }
}
Sys.time()

selGenes <- lapply(avExpList, 
                   function(x) which(unlist(apply(x, 1, max)) > 1))
for (i in 1:length(selGenes)) {
  avExpList[[i]] <- avExpList[[i]][selGenes[[i]], ]
}

setwd("~/__Data")
save(avExpList, file="avExpList_HD_noFilter.RData")
```

## Expression correlation

```{r correlationAnalysis}
library(Hmisc)
# corrList <- lapply(avExpList, function(x) {
#                   if (ncol(x) > 4) rcorr(t(x)) 
#                   })
# names(corrList)[lapply(corrList, length) == 0] # "BRISL2:C5" "BRISL2:C7"
# corrList <- corrList[lapply(corrList, length) > 0]
# setwd("~/__Data"); getwd()
# save(corrList, file="corrList.RData")
corrList <- get(load("corrList.RData"))

library(corrplot)
setwd("~/__Data"); getwd()
pdf("shelfLifeCorrPlots.pdf")
for (i in 1:length(corrList)) {
    x <- corrList[[i]]
    if (length(x) > 0) {
        x$P[which(is.na(x$P))] <- 1
        x$r[which(is.na(x$r))] <- 0
        x$r[x$r < -1 | x$r > 1] <- 0
        myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988", 
                              "#FFFFFF", "#77AADD", "#4477AA")))
        corrplot(x$r, type="upper", order="hclust", method="color",
                 p.mat = x$P, sig.level = 0.01, insig = "blank", 
                 col=myColors(200), diag=FALSE, tl.col="black", 
                 tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
                 mar = c(1, 1, 1, 1), hclust.method="complete")
    }
}
dev.off()

coExpMtrx = NULL
for (i in 1:length(corrList)) {
  x <- corrList[[i]]
  # Filter out unreliable P's:
  x$P[which(is.na(x$P))] <- 1
  x$P[which(is.nan(x$P))] <- 1
  x$P[which(is.na(x$r))] <- 1
  x$P[x$r < 0 | x$r > 1] <- 1
  coExpCount <- apply(x$P, 1, function(Y) length(which(Y < 0.01)))
  coExpMtrx <- rbind(coExpMtrx, coExpCount)
}
rownames(coExpMtrx) <- names(corrList)

library(pheatmap)
selGenes <- names(which(corrList[[3]]$P["CDC42", ] == 0))
mtrx <- avExpList[[names(corrList)[3]]][selGenes, ]
mtrx <- t(apply(mtrx, 1, scale))
colnames(mtrx) <- colnames(avExpList[[names(corrList)[3]]])
setwd("~/__Data"); getwd()
pdf("BRISL2.LoupeC3.corrCDC42.heatmap.pdf")
pheatmap(mtrx, cluster_cols=FALSE)
dev.off()

X <- avExpList[[names(corrList)[3]]][selGenes, ]
maxY <- max(X)
plot(c(1,5), c(0,maxY))
for (i in selGenes) {
  lines(X[i, ], col=rgb(0,0,0,0.25))
}


#### Correlation across all 3 donors:
setwd("~/__Data")
pdf("corrPlot_allClusters_allSamples.pdf")
for (cl in 1:10) {
  Q <- paste0(":C", cl, "$")
  subList <- avExpList[grep(Q, names(avExpList))]
  geneList <- lapply(subList, rownames)
  shared <- table(do.call(c, geneList))
  shared <- names(shared)[shared == 3]
  subList <- lapply(subList, function(x) x[shared, ])
  clusterExp <- do.call(cbind, subList)
  
  library(Hmisc)
  clusterCorr <- rcorr(t(clusterExp))
  
  corrMtrx <- clusterCorr$r
  corrMtrx[corrMtrx > 1] <- 0
  library(corrplot)
  myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988",
  "#FFFFFF", "#77AADD", "#4477AA")))
  corrplot(corrMtrx, type="upper", order="hclust", method="color",
          p.mat = x$P, sig.level = 0.05, insig = "blank",
          col=myColors(200), diag=FALSE, tl.col="black",
          tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
          mar = c(1, 1, 1, 1), hclust.method="ward.D2", main=
          paste0("Loupe Cell Type Cluster ", cl))
  }
dev.off()

###################################################################
#  For each donor, take median expression per gene per timepoint  #
###################################################################
# library(foreach)
# library(doParallel)
# HPC <- makeCluster(64)
# registerDoParallel(HPC)
# donor = avExp = NULL
# avExp <- foreach(ID = c("BRISL3", "BRISL4"), 
#                  hr = c("1h", "2h"), 
#                  CL = 1:3, 
#                  .combine = "rbind", .verbose = TRUE) %dopar% { 
#   indx <-  which(clusters$Cluster == CL)
#   cellType <- as.matrix(normalizedPBMC[ , indx])
#   donor <- cellType[ , grep(ID, colnames(cellType))]
#   donor <- apply(donor, 2, function(x) log2(x + 1))
#   selCols <- grep(hr, colnames(donor))
#   apply(donor[ , selCols], 1, median)
# }
# setwd("~/__Data"); getwd()
# save(avExp, file="avExpPerDonorPerTimepoint.RData")
```


```{r mFuzzCLustering}

setwd("~/__Data")
avExpList <- get(load("avExpList.RData"))

library(Mfuzz)
setwd("~/__Data")
pdf('mfuzzClusters.pdf')
allClusters = list()
for (i in 1:length(avExpList)) {
  eset <- ExpressionSet(avExpList[[i]])
  eset <- filter.std(eset, min.std = 0.1, visu = FALSE) 
  M <- mestimate(eset); M
  eset <- standardise(eset)
  cl <- mfuzz(eset, c=4, m=M)
  allClusters[[i]] <- cl
  shortName <- gsub("BRISL|C", "", names(avExpList)[i])
  tLabels <- paste0(shortName, ":", 
                    c("2", "4", "6", "8", "18")[1:ncol(avExpList[[i]])])
  # mfuzz.plot(eset, cl=cl, mfrow=c(2, 2), new.window=FALSE,
  # 		   time.labels=tLabels,
  # 		   min.mem=0.5) 
}
dev.off()
names(allClusters) <- names(avExpList)
setwd("~/__Data")
# save(allClusters, file="all.mFuzz.clusters.RData")
allClusters <- get(load("all.mFuzz.clusters.RData"))

selCL <- allClusters[[1]][[3]]
selGenes <- names(selCL[selCL == 4])

X <- avExpList[[names(allClusters)]][selGenes, ]
maxY <- max(X)
setwd("~/__Data")
pdf("BRISL2.LoupeC1.mFuzzCluster4_timeCourse.pdf")
plot(c(1,5), c(0,maxY), col=rgb(1,1,1,0), xaxt="n", 
     xlab="timepoint", ylab="Normalized log2 expression")
axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
for (i in 1:length(selGenes)) {
  lines(X[selGenes[i], ], col=i) # rgb(0,0,0,0.25)
}
dev.off()

# Get cluster member genes for visually-identified up in 4-6 hours clusters:
# BRISL2:C6   mFuzz cluster 1
# BRISL3:C6   mFuzz cluster 1
# BRISL4:C6   mFuzz cluster 2
B2C6 <- names(which(allClusters[["BRISL2:C6"]]["cluster"][[1]] == 1))
B3C6 <- names(which(allClusters[["BRISL3:C6"]]["cluster"][[1]] == 1))
B4C6 <- names(which(allClusters[["BRISL4:C6"]]["cluster"][[1]] == 2))
# intersect(intersect(B2C6, B3C6), B4C6) # empty
# sort(table(c(B2C6, B3C6, B4C6))) # REL == 2, IRF1 == 2

B2C7.1 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 1))
B2C7.4 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 4))
B3C7 <- names(which(allClusters[["BRISL3:C7"]]["cluster"][[1]] == 4))
B4C7 <- names(which(allClusters[["BRISL4:C7"]]["cluster"][[1]] == 3))
B2 <- unique(c(B2C7.1, B2C7.4))
sort(intersect(intersect(B2, B3C7), B4C7))
# "NACA"  "RPL31" "RPL35" "RPL36" "RPS19" "RPS21" "RPS26" "RPS29" "SRP14" "SUB1"
# The 7 RPL/RPS genes are involved in Ag presentation (as well as protein translation)

# pDCs == loupe cluster 10
B2C10 <- names(which(allClusters[["BRISL2:C10"]]["cluster"][[1]] == 2))
B3C10.1 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 1))
B3C10.2 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 2))
B4C10.2 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 2))
B4C10.4 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 4))
B3 <- unique(c(B3C10.1, B3C10.2))
B4 <- unique(c(B4C10.2, B4C10.4))
rev(sort(table(c(B2C10, B3, B4))))
# TRIR                   SPCS3                   SNRPB                  SEC11C 
#    3                       3                       3                       3
# TargetMine: cellular nitrogen compound metabolic process [GO:0034641]
# All 4 genes are associated with cd123+ plasmacytoid dcs 	BH-adjP=0.0175 

# Plot timecourse of AvExp of above 4 genes:
IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")
# genes.pDC <- c("TRIR","SPCS3", "SNRPB","SEC11C")
genes.pDC <- c("NACA","RPL31","RPL35","RPL36","RPS19","RPS21","RPS26","RPS29","SRP14","SUB1")
myColors <- c("cyan", "forestgreen", "red") 

setwd("~/__Data")
pdf("LoupeCluster7_genesAfftedAt4to6Hours_timeCourse.pdf")
par(mfrow=c(2,2))
for (g in genes.pDC) {
  expVals = NULL
  for (ID in IDs){
    expVals <- c(expVals, avExpList[[paste0(ID, ":C10")]][g, ])
  }
  MAX <- max(expVals)
  MIN <- min(expVals)
  plot(c(1, 5), c(MIN, MAX), xaxt='n', xlab="timepoint", 
       ylab="log2(normReads+1)", col="white", main=paste0(g))
  axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
  for (i in 1:length(IDs)) {
    vals <- avExpList[[paste0(IDs[i], ":C10")]][g, ]
    lines(1:5, vals, col=myColors[i], type='b')
  }
}
dev.off()

```

## HB: marker gene enrichment analysis 

```{r enrichment}
library(clusterProfiler)
library(gage)
library(pathview)

setwd("~/__Data")
DE.2.4.old <- get(load("DE2to4hr_pVals_adjFDR.RData"))
DE.2.4 <- get(load("shelfLife_HD_DE2to4hr_pVals_adjFDR_v2.RData"))
markersListOld <- lapply(DE.2.4.old, function(x) names(x))
markersList <- lapply(DE.2.4, function(x) names(x)) # same except no cluster 10

keggPathways = NULL
for (i in 1:length(markersList)) {
  markerEGs <- id2eg(markersList[[i]])[ ,'ENTREZID']
  markerEGs <- markerEGs[!is.na(markerEGs)]

  keggE <- enrichKEGG(gene = markerEGs, organism = 'hsa', pvalueCutoff = 1) # NB p = 1

  indx <- which(keggE$qvalue < 0.05)
  if (length(indx > 0)) {
    iPathways <- data.frame(clusterNo=i, publishedLabel=names(DE.2.4)[i],
                            pathway=keggE$Description[indx],
                            pValue=keggE$qvalue[indx])
    keggPathways <- rbind(keggPathways, iPathways)
  }
  print(i)
}
setwd("~/__Data")
save(keggPathways, file="keggPathways_shelfLifeHD_DE2to4.RData")
write.csv(keggPathways, file="keggPathways_shelfLifeHD_DE2to4.CSV")
```



## Seurat general analyses

```{r pca,results='hide'}
# pbmc <- RunPCA(object = pbmc, features = VariableFeatures(object = pbmc))
# names(pbmc) #  "RNA" "SCT" "pca"
# pbmc[['pca']]@feature.loadings[1:5,1:5] 
```

```{r pca_viz, message=TRUE}
# Examine and visualize PCA results a few different ways
# print(x = pbmc[['pca']], dims = 1:5, nfeatures = 5)
# VizDimLoadings(object = pbmc, dims = 1:2, reduction = 'pca')
# DimPlot(object = pbmc, reduction = 'pca')

# `DimHeatmap` can be useful when deciding which PCs to include. 
# Cells and features are ordered according to their PCA scores. 
# `cells` = 'a number' plots the 'extreme' cells on both ends of the spectrum, 
# which dramatically speeds plotting for large datasets. 

# DimHeatmap(object = pbmc, dims = 1:15, cells = 500, balanced = TRUE)
```

### Determine the 'dimensionality' of the dataset

```{r jackstraw}
# NOTE: SLOW, comment out and use ElbowPlot()
# pbmc <- JackStraw(object = pbmc, num.replicate = 100)
# pbmc <- ScoreJackStraw(object = pbmc, dims = 1:20)
```

Use elbow plot instead:

```{r elbow_plot}
# ElbowPlot(object = pbmc)
# choose 10 here, but :
# genes strongly associated with PCs 12 and 13 define rare DC and NK subsets 

```


### Cluster the cells

See [[SNN-Cliq, Xu and Su, Bioinformatics, 2015]](http://bioinformatics.oxfordjournals.org/content/early/2015/02/10/bioinformatics.btv088.abstract) and CyTOF data [[PhenoGraph, Levine *et al*., Cell, 2015]](http://www.ncbi.nlm.nih.gov/pubmed/26095251). 

To cluster the cells, can use the Louvain algorithm (default) or SLM [[SLM, Blondel *et al*., Journal of Statistical Mechanics]](http://dx.doi.org/10.1088/1742-5468/2008/10/P10008) via `FindClusters`.

A resolution parameter sets the 'granularity' of the downstream clustering (larger values, more clusters) ~ typical range 0.4-1.2 

The clusters can be found using the `Idents` function.


```{r cluster}
# pbmc <- FindNeighbors(object = pbmc, dims = 1:10)
# pbmc <- FindClusters(object = pbmc, resolution = 0.5)

# Assigned cluster numbers:     
# clusterIDs <- Idents(object = pbmc)
# table(clusterIDs) # Note: getting a 14-cell tenth cluster!
#   0   1   2   3   4   5   6   7   8   9 
# 654 443 365 347 273 206 157 146  33  14 
```

### Run non-linear dimensional reduction (UMAP/tSNE)

Use the same PCs as input to the clustering analysis.

```{r tsne}
# Install UMAP, via pip or reticulate::py_install(packages = "umap-learn")
# pbmc <- RunUMAP(object = pbmc, dims = 1:10)
# Coords of UMMAP plot are in     pbmc[['umap']]@cell.embeddings

# Set `label = TRUE` or use the LabelClusters function for labeling
# DimPlot(object = pbmc, reduction = 'umap', label = TRUE)

# saveRDS(pbmc, file = "~/Desktop/filtered_gene_bc_matrices/pbmc_tutorial.rds")
```

### Finding differentially expressed features per cluster

"min.pct"
"max.cells.per.ident" will downsample each identity class to save time.

```{r markerAnalysis, fig.height=8, fig.width=15}
# find all markers of cluster 1
#cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
#head(x = cluster1.markers, n = 5)

# find all markers distinguishing cluster 5 from clusters 0 and 3
# cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(x = cluster5.markers, n = 5)

###################################################################################
# find markers for every cluster compared to all remaining cells:
# pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC) # top 2 +ve FC markers per cluster
# save(pbmc.markers, file="pbmc3k_markers.RData")

# see  [DE vignette](http://satijalab01.nygenome.org/seurat/v3.0/de_vignette.html) for more DE methods.

# cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 0, 
                                 # logfc.threshold = 0.25, test.use = "roc", 
                                 # only.pos = TRUE)
# 
# # `VlnPlot` == probability distributions across clusters)
# # `FeaturePlot` == feature expression on a tSNE or PCA plot)
# # See also `RidgePlot`, `CellScatter`, and `DotPlot`.
# 
# VlnPlot(object = pbmc, features = c("MS4A1", "CD79A"))
# # raw counts:
# VlnPlot(object = pbmc, features = c("NKG7", "PF4"), slot = 'counts', log = TRUE)
# FeaturePlot(object = pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", 
               # "FCGR3A", "LYZ", "PPBP", "CD8A"))

# `DoHeatmap` generates an expression heatmap for given cells and features. 

# pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC) -> top10
# DoHeatmap(object = pbmc, features = top10$gene) + NoLegend()

# new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", 
                     # "FCGR3A+ Mono", "NK", "DC", "Mk", "blob")
# names(x = new.cluster.ids) <- levels(x = pbmc)
# pbmc <- RenameIdents(object = pbmc, new.cluster.ids)
# DimPlot(object = pbmc, reduction = 'umap', label = TRUE, pt.size = 0.5) + NoLegend()

# library(ggplot2)
# plot <- DimPlot(object = pbmc, reduction = "umap", label = TRUE, label.size = 4.5) + xlab("UMAP 1") + ylab("UMAP 2") + 
#   theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + 
 #  guides(colour = guide_legend(override.aes = list(size = 10)))
# ggsave(filename = "~/Desktop/filtered_gene_bc_matrices/hg19/pbmc3k_umap.png", height = 7, width = 12, plot = plot)
```


```{r etc}
# First, in the "Compute engine console", use the SSH button to bring up a shell and install these:
sudo apt-get install libcurl4-openssl-dev
sudo apt-get install libssl-dev

# Then in R, run:
install.packages('Seurat', repos="https://cloud.r-project.org")
install.packages("liger")
linstall.packages("knitr")

````
