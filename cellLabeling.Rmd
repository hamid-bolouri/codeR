---
title: "cellLabeling"
author: "HB"
date: "6/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```

# Allocate memory and use N CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 32)    ############### N CPUs ###################
options(future.globals.maxSize = 20 * 1024 ^ 3) # max object size

library("future.apply")
library("stats")
# future_lapply(1:10, FUN = quantile, probs = 1:3/4)
```


```{r loadData}

library("tidyverse")
library("Matrix")

setwd("~/__Data")
normalizedPBMC <- get(load("SeuratNormalizedCounts_GRCh38_filteredMT.RData"))
PBMC.IDs <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[1]))
timePoints <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[3]))

setwd("~/__Data")
CLs <- read.csv("clusters.csv", as.is=TRUE, header=FALSE, skip=1, 
                col.names=c("clusterTags", "clusterNo"))
clustIDs <- unlist(lapply(strsplit(CLs$clusterTags, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clustIDs), ]
rownames(CLs) <- colnames(normalizedPBMC)

library("Seurat")
pbmc <- CreateSeuratObject(counts=normalizedPBMC, project="shelfLife", min.cells=3, 
                           min.features=200, meta.data=CLs)
Idents(pbmc) <- paste0("C", CLs$clusterNo) # use cellRanger clusters

rm(normalizedPBMC)
gc()

# find markers for every cluster compared to all remaining cells, report only the up-reg
# pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, 
#                                min.pct = 0.25, logfc.threshold = 0.25)
# # table(pbmc.markers$cluster)
# #   6    2    1    3    4    8    9   10    7    5 
# # 201 1011  145   79  290  408  663  874    2  124 
# # top 10 markers per cluster:
# top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n=10, wt = avg_logFC) 
# top10 <- top10$gene
setwd("~/__Data")
# save(pbmc.markers, file="pbmcShelfLife10X_markers.RData")
pbmc.markers <- get(load("pbmcShelfLife10X_markers.RData"))

AdamLabels <- c(C1="naiveT", C2="mono", C3="activatedT", C4="NK/Tgd", C5="18h.5", 
                C6="B", C7="noMarker", C8="PMN.2", C9="platelets", C10="pDC")

library(SingleCellExperiment)
pbmc.sce <- as.SingleCellExperiment(pbmc)
indx <- match(colData(pbmc.sce)$ident, names(AdamLabels))
colData(pbmc.sce)$ident <- AdamLabels[indx]
# table(colData(pbmc.sce)$ident)
#      18h.5 activatedT          B       mono     naiveT     NK/Tgd   noMarker        pDC  platelets      PMN.2 
#      11501      23483       8029      27937      38868      13387        133        767        413       1036 

# Not Run: requires >350GB of RAM !
# all.genes <- rownames(pbmc)
# pbmc <- ScaleData(pbmc, features = all.genes)
# DoHeatmap(pbmc, features=top10)

setwd("~/__Data")
save(pbmc.sce, file="pbmc.sce_shelfLife.HD.RData")
```


# correlation to published signatures

```{r sigCorr}

setwd("~/__Data")
pbmc.sce <- get(load("pbmc.sce_shelfLife.HD.RData"))

setwd("~/__Data/signatures")
LM22 <- read.delim("CIBERSORT_LM22.txt", header=TRUE, row.names=1, as.is=TRUE) 
GSE107011 <- read.csv("PBMC_17of_29CellTypesRNAseqSignatures.csv", 
                      header=TRUE, row.names=1, as.is=TRUE) 
pmid30413720 <- read.csv('immunoStates_320Genes20CellTypes_signature.csv',
                         skip=2, header=TRUE, row.names=1, as.is=TRUE) # 20 cell types

library(Hmisc)
library(lsa)

# classSig: Set to one of: # LM22 # GSE107011 # pmid30413720

calcSigs <- function(classSig) {
  typesTbl = corrsTbl = list()
  for (i in 1:length(AdamLabels)) {
    iClust <- AdamLabels[i]
    j <- which(colData(pbmc.sce)$ident == iClust)
    sharedGenes <- intersect(rownames(pbmc.sce), rownames(classSig))
  
    selExp <- as.matrix((counts(pbmc.sce))[sharedGenes, j])
    selSig <- as.matrix(classSig[sharedGenes, ])
    corrList <- future_apply(selExp, 2, FUN=function(y) rcorr(y, selSig))
    
    rList <- lapply(corrList, function(x) x$r)
    bestMatch <- unlist(lapply(rList, function(x) {
                      x[lower.tri(x, diag=TRUE)] <- NA
                      x <- x[1, -1]
                      return(names(which(x == max(x, na.rm=TRUE))))
                      }))
  
    bestCorr <- unlist(lapply(rList, function(x) {
                      x[lower.tri(x, diag=TRUE)] <- NA
                      x <- x[1, -1]
                      return( x[which(x == max(x, na.rm=TRUE))] )
                      }))
  
    matchTbl <- rev(sort(table(bestMatch)))
    typesTbl[[i]] <- matchTbl/sum(matchTbl)
    
    corrVals = NULL
    for (iCorr in 1:length(matchTbl)) {
      corrVals <- c(corrVals, median(bestCorr[grep(names(matchTbl)[iCorr], names(bestCorr))]))
    }
    corrsTbl[[i]] <- corrVals
  }
  names(typesTbl) <- AdamLabels
  names(corrsTbl) <- AdamLabels
  
  sigsList = list()
  for (A in 1:length(AdamLabels)) {
    DF <- data.frame("cell type"=typesTbl[[A]], "correlation to signature"=corrsTbl[[A]])
    sigsList[[A]] <- DF
  }
  return(sigsList)
}

allSigs = list(); loopCount = 0
mySigs <- list(LM22, GSE107011, pmid30413720)
for (signature in mySigs) {
  loopCount <- loopCount + 1
  print(paste0(Sys.time(), "    ", loopCount))
  allSigs[[loopCount]] <- calcSigs(classSig = signature)
}
names(allSigs) <- c("LM22", "GSE107011", "pmid30413720")

setwd("~/__Data")
save(sigsList, file="predictedCellTypes_fracCells_all3Sigs.RData")
# save(typesTbl, file="predictedCellTypes_fracCells_LM22.RData")
# save(corrsTbl, file="predictedCellTypes_medCorrs_LM22.RData")


library(ggrepel)
setwd("~/__Plots")
pdf("shelfLife_HD_cellTypes2DPlot_allSigs.pdf", height=12, width=12)
for (indx in 1:length(typesTbl)) {
    DF1 <- allSigs[[1]][[indx]]
    DF2 <- allSigs[[2]][[indx]]
    DF3 <- allSigs[[3]][[indx]]
    colnames(DF1)[2] = colnames(DF2)[2] = colnames(DF3)[2] = "fraction.of.cells"
    DF1$sig <- names(allSigs)[1]
    DF2$sig <- names(allSigs)[2]
    DF3$sig <- names(allSigs)[3]
    DF <- rbind(DF1, DF2, DF3)
    
    print(ggplot(DF, aes(fraction.of.cells, correlation.to.signature, label = cell.type.bestMatch, color=sig)) +
    geom_text_repel() +
    geom_point() +
    ggtitle(names(typesTbl)[indx]) +
    theme_classic(base_size = 16))
}
dev.off()


# typesTbl <- get(load("predictedCellTypesList_LM22.RData"))
# resTbl <- lapply(typesTbl, function(x) x[1:3])
# setwd("~/__Plots")
# pdf("predictedCellTypesList_LM22.pdf")
# par(mar=c(25,5,5,2))
# for (i in 1:length(resTbl)) {
#   barplot(resTbl[[i]], col="skyblue", border="white", 
#           las=2, width=rep(0.25, 3), ylab="score", main=names(resTbl)[i])
# }
# dev.off()
# 
# par(mfrow = c(5, 2))
# for (indx in 1:length(typesTbl)) {
#   plot(corrsTbl[[indx]], typesTbl[[indx]], xlab="fraction of cells",
#        ylab="correlation to signature", main=names(typesTbl)[indx], pch=20, 
#        cex=0.5, col=rgb(0,0.65,1,0.5), cex.axis=1,
#        xlim=c(0,1), ylim=c(0,1), yaxt="n")
#   text(corrsTbl[[indx]], typesTbl[[indx]], labels=names(typesTbl[[1]]), 
#        pos=3, cex=0.75)
#   axis(side=2, at=(0:10)/10, labels=signif((0:10)/10, 1), las=2)
# }


```

# Pathway Enrichment:

```{r overReprsentation}
library(clusterProfiler)
library(gage)
library(pathview)

markersList <- split(rownames(pbmc.markers), pbmc.markers$cluster)

keggPathways = NULL
for (i in 1:length(markersList)) {
  markerEGs <- id2eg(markersList[[i]])[ ,'ENTREZID']
  markerEGs <- markerEGs[!is.na(markerEGs)]

  keggE <- enrichKEGG(gene = markerEGs, organism = 'hsa', pvalueCutoff = 1) # NB p = 1

  indx <- which(keggE$qvalue < 0.05)
  if (length(indx > 0)) {
    iPathways <- data.frame(clusterNo=i, publishedLabel=AdamLabels[i],
                            pathway=keggE$Description[indx],
                            pValue=keggE$qvalue[indx])
    keggPathways <- rbind(keggPathways, iPathways)
  }
  print(i)
}

setwd("~/__Data")
save(keggPathways, file="keggPathways_clustersShelfLife.HD.RData")
```

# GSEA:

```{r GSEA}
orderedMarkers <- pbmc.markers[order(pbmc.markers$avg_logFC, decreasing=TRUE), ]
markerListGSEA <- split(pbmc.markers$avg_logFC, pbmc.markers$cluster)
IDs <- split(pbmc.markers[ ,"gene"], pbmc.markers$cluster)
for (i in 1:length(markerListGSEA)) {
  names(markerListGSEA[[i]]) <- IDs[[i]]
}

resGSEA = NULL
for (i in 1:length(markerListGSEA)) {
  egIDs <- id2eg(names(markerListGSEA[[i]]))
  markersGSEA <- markerListGSEA[[i]][!is.na(egIDs)]
  names(markersGSEA) <- egIDs[ , "ENTREZID"]
  markersGSEA <- rev(sort(markersGSEA))
  res <- gseKEGG(geneList = markersGSEA, organism = 'hsa', nPerm = 1000, 
                 minGSSize = 1, pvalueCutoff = 0.05, verbose = FALSE) # NB minGS = 1
  if (length(res$ID) > 0) {
    resDF <- data.frame(clusterNo=i, AdamLabel=AdamLabels[i],
                        pathway=res$Description, pValue=res$qvalues)
    resGSEA <- rbind(resGSEA, resDF)
  }
}

setwd("~/__Data")
save(resGSEA, file="keggGSEA_pbmc3k.RData")
```
