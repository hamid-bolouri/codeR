---
title: "shelfLife_SLE"
author: "HB"
date: "July/10/2019"
output:
  html_document:
    theme: united
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```

### Allocate memory  and use all CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 64)    ############## set number of CPUs #################
options(future.globals.maxSize = 20 * 1024 ^ 3)

library("future.apply")
library("stats")
```

### Refs

Based on https://www.dropbox.com/s/38h5zccv0b7l9pr/pbmc3k_tutorial.Rmd?dl=1
See also: https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html
`Seurat` object wiki [GitHub Wiki](https://github.com/satijalab/seurat/wiki). 


```{r init}
library(dplyr)
library(Seurat)

# Load the PBMC dataset
setwd("~/__Data/shelfLifeSLE/outs")
SLE <- Read10X("filtered_feature_bc_matrix") # 33,538 x 141,853

setwd("~/__Data/shelfLifeSLE/")
meta <- get(load("Aggr_Human_Immunology_RTX-850-856_GRCh38-3.0.0_premrna_samp.dat_v3_reads.RData"))
selMetaCols <- c("library_id", "Lib_Name", "Sample_Name", "time_point", 
                 "doublet.score", "Exclude", "Exclude2")
selMetaCols <- c(1, match(selMetaCols, colnames(meta)))

colNames <- unlist(lapply(strsplit(colnames(SLE), "-"), function(x) x[1]))

# cell barcodes are only unique _within_ libs, so match per library:
myMat = colData = NULL
for (libID in c("^BRISL5-","^BRISL6-","^BRISL7-")) {
   print(libID)
   iLib <- grep(libID, meta$Lib_Name) 
   metaLib <- meta[iLib, ]
   
   metaTags <- unlist(lapply(strsplit(metaLib[ , 1], "-"), function(x) x[1])) 
   
   iGood <- match(metaTags, colNames)
   myMat <- cbind(myMat, SLE[ , iGood[!is.na(iGood)]])
   colData <- rbind(colData, metaLib[which(!is.na(iGood)), selMetaCols])
} # ncol(myMat) == nrow(colData) == 138,788

colnames(colData)[1] <- "uniqueID"
colnames(myMat) <- colData[ ,"uniqueID"]

setwd("~/__Data/shelfLifeSLE/outs")
save(myMat, file="shelfLifeSLE_myMat.RData")
save(colData, file="shelfLifeSLE_colData.RData")

# Initialize the Seurat object 
pbmc <- CreateSeuratObject(counts = myMat, project = "pbmcAging", min.cells = 3, min.features = 200)
rm(myMat)
gc()

```


```{r}
# Examine a few genes in the first thirty cells
# pbmc.data[c("CD3D","TCL1A","MS4A1"), 1:30]
```

```{r mito, fig.height=7, fig.width=13}
# The [[.]] operator can add columns to object metadata 
pbmc[["percent.mt"]] <- PercentageFeatureSet(object = pbmc, pattern = "^MT-")
hist(unlist(pbmc[["percent.mt"]]), breaks=50, col="skyblue", main="",
     border="white", xlab="Percentage of genes that are mitochondrial") # long tail past 20% MT

IDs <-rownames(pbmc@meta.data)
IDs <- strsplit(IDs, "-")
donors <- unlist(lapply(IDs, function(x) x[2]))
timePoints <- unlist(lapply(IDs, function(x) x[3]))
timePoints[timePoints == "18h"] <- "hr18"
plotPoints <- data.frame(pbmc[["percent.mt"]], TimePoint=timePoints)

# library(beeswarm)
# beeswarm(plotPoints)

library(ggplot2) # , fill=TimePoint
theme_update(text = element_text(size=20))
ggplot(plotPoints, aes(x=TimePoint, y=percent.mt, color=TimePoint)) + 
geom_violin() +
stat_summary(fun.data=mean_sdl, mult=1, 
             geom="pointrange", color=rgb(0,0,0,1)) +
theme(axis.text.x = element_text(size = 20), 
      axis.text.y = element_text(size = 20))

```

```{r qc, fig.height=7, fig.width=13}
# Show QC metrics for the first 5 cells
head(x = pbmc@meta.data, 5)
```

```{r qc2, fig.height=7, fig.width=13}

# Visualize QC metrics as a violin plot
VlnPlot(object = pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3, pt.size = 0)

plot1 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
CombinePlots(plots = list(plot1,plot2))

pbmc <- subset(x = pbmc, subset = nFeature_RNA > 500 & nFeature_RNA < 6000 & percent.mt < 15)
gc()
```

### Normalizing the data

Default is a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression. Normalized values are stored in `pbmc[["RNA"]]@data`.

```{r normalize}
# Not run. See scTransform below.
# pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 1e4)
```

```{r var_features, fig.height=5, fig.width=11}
pbmc <- FindVariableFeatures(object = pbmc,selection.method = 'vst', nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(x = VariableFeatures(object = pbmc), 10)
top500 <- head(x = VariableFeatures(object = pbmc), 500)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(object = pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1 , plot2))
```

### Scaling the data

Counts -> Z-scores for PCA, etc.

```{r regress, fig.height=7, fig.width=11, results='hide'}
# Old Seurat approach to normalization & scaling with individual commands:
# all.genes <- rownames(x = pbmc)

# 'vars.to.regress' filters out bad cells:
# pbmc <- ScaleData(object = pbmc, features = all.genes)
```

However, `sctransform` is the new recommended method and comes with a `vars.to.regress` parameter.

```{r scaling and normalization, results='hide'}
# Save pbmc. Switch to high-memory instance!
setwd("~/__Data/shelfLifeSLE/outs")
# save(pbmc, file="Seurat.pbmc.pre.scTransform_shelfLifeSLE.RData")
pbmc <- get(load("Seurat.pbmc.pre.scTransform_shelfLifeSLE.RData"))

gc()
pbmc <- SCTransform(object = pbmc, verbose = FALSE, vars.to.regress = 'percent.mt', conserve.memory = TRUE)
# Transformed data will be available in the SCT assay, 
# which is set as the default after running sctransform

# names(pbmc) #  "RNA" "SCT" 
normalizedPBMC <- GetAssayData(object = pbmc, assay="SCT", slot = "data")
setwd("~/__Data/shelfLifeSLE/")
# getwd()
save(normalizedPBMC, file="SeuratNormalizedCountsSLE_GRCh38_filteredMT.RData")
save(pbmc, file="seuratObj_pbmc_shelfLifeSLE.RData")
# nonZeros <- as.matrix(normalizedPBMC); nonZeros <- nonZeros[(nonZeros > 0)]
# hist(nonZeros, breaks=10) # nothing above ~5.5, most values between 1 and 2.
```

## Get normalizedPBMC

```{r get_normalizedPBMC}
library("Matrix")
library(dplyr)
library(Seurat)

setwd("~/__Data/shelfLifeSLE/outs")
# myMat <- get(load("shelfLifeSLE_myMat.RData"))
colData <- get(load("shelfLifeSLE_colData.RData"))

setwd("~/__Data/shelfLifeSLE")
normalizedPBMC <- get(load("SeuratNormalizedCountsSLE_GRCh38_filteredMT.RData"))
PBMC.IDs <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[1]))
 
setwd("/home/hamid.bolouri/__Data/shelfLifeSLE/outs/analysis/clustering/kmeans_10_clusters/")
CLs <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(CLs$Barcode, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clusterIDs), ]
CLs$Barcode <- colnames(normalizedPBMC)

# setwd("~/__Data/shelfLifeSLE/outs")
# write.csv(CLs, file="shelfLife_SLE_LoupeK10Clusters.csv")
# save(CLs, file="helfLife_SLE_LoupeK10Clusters.RData")

colnames(CLs) <- c("ID", "group")
CLs$group<- as.factor(CLs$group)
library(S4Vectors)
CLs <- DataFrame(CLs)

IDs = c("BRISL5", "BRISL6", "BRISL7")
HRs = c("-2hr", "-4hr", "-6hr", "-8hr", "-18hr")

```

### Pathway analysis

```{r differentialExpression}
setwd("~/__Data"); 

#### Look for genes DE across timepoints  
#### See bottom of this section for Adam version 
runDE <- function(time1, time2) {
  
   testDE <- function(x) {
     x1 <- x[grep(paste0("-", time1, "hr$"), names(x))]
     x2 <- x[grep(paste0("-", time2, "hr$"), names(x))]
     x1 <- x1[x1 > 0]
     x2 <- x2[x2 > 0]
     # Consider only clutsers with > 100 cells
     if (length(x1) > 100 & length(x2)>100) {
       wilcox.test(x1, x2)$p.value
     }
   }

   clusterNos = 1:10
   res = NULL; N = 0
   resList = resLabels = list()
   Sys.time()
   for (cl in clusterNos) {
     i.CL <- grep(cl, CLs$group)
     clTbl <- normalizedPBMC[ , i.CL]
   
     stepSize = 1000
     M <- dim(clTbl)[1] - stepSize
     i1 = i2 = 0; res = NULL
     while (i2 < M) {
       i1 <- i2 + 1; i2 <- i2 + stepSize
       res1 <- unlist(future_apply(clTbl[i1:i2, ], 1, FUN = testDE))
       res1 <- res1[res1 < 0.01 & !is.na(res1)]
       res <- c(res, res1)
       print(i1)
     }
     
     remaining <- (i2+1):(dim(clTbl)[1])
     res2 <- unlist(future_apply(clTbl[remaining, ], 1, FUN = testDE))
     res2 <- res2[res2 < 0.01 & !is.na(res2)]
     res <- c(res, res2)
     if (!is.null(res)) {
        N <- N +1
        resList[[N]] <- res
        resLabels[[N]] <- paste0("cluster", cl)
        print(paste0("cluster ", cl, "  time:", Sys.time()))
     }
   }
   
   # res.adj <- lapply(resList, function(x) p.adjust(x, method="fdr")) 
   # NB. Previous method above only corrected for number of tests KEPT!
   res.adj <- lapply(resList, function(x) x * nrow(clTbl))
   res.adj <- lapply(res.adj, sort)
   names(res.adj) <- unlist(resLabels)
   res.adj <- res.adj[which(unlist(lapply(res.adj, length) > 0))]
   return(res.adj)
}

T1 = 2
for (T2 in c(4, 6, 8)) {
  print(Sys.time())
  res.adj <- runDE(time1=T1, time2=T2)
  setwd("~/__Data/shelfLifeSLE")
  save(res.adj, file=paste0("shelfLifeSLE_DE", T1, "to", T2, "hr_pVals_adjFDR_v2.RData"))
  library(erer)
  setwd("~/__Data/shelfLifeSLE")
  write.list(z=res.adj, 
             file=paste0("shelfLifeSLE_DE", T1, "to", T2, "hr_pVals_adjFDR_v2.CSV"), 
             row.names=TRUE)
}

setwd("~/__Data/shelfLifeSLE")
DE2.4 <- get(load("shelfLifeSLE_DE2to4hr_pVals_adjFDR_v2.RData"))
DE2.6 <- get(load("shelfLifeSLE_DE2to6hr_pVals_adjFDR_v2.RData"))
DE2.8 <- get(load("shelfLifeSLE_DE2to8hr_pVals_adjFDR_v2.RData"))

# library("VennDiagram")
library("eulerr")

setwd("~/__Plots")
pdf("shelfLifeSLE_DE2.4.6.8_Venns.pdf")
par(mfrow = c(2, 3))
for (i in names(DE2.4)) {
  genes2.4 <- names(DE2.4[[i]][which(DE2.4[[i]] < 0.01)])
  genes2.6 <- names(DE2.6[[i]][which(DE2.6[[i]] < 0.01)])
  genes2.8 <- names(DE2.8[[i]][which(DE2.8[[i]] < 0.01)])
  print(plot(euler(list(DE2.4=genes2.4, DE2.6=genes2.6, DE2.8=genes2.8), 
             shape = "ellipse"), quantities = TRUE, main=i,  
       col=c("red", "blue", "green")))
}
dev.off

shared = list()
for (i in names(DE2.4)) {
  genes2.4 <- names(DE2.4[[i]][which(DE2.4[[i]] < 0.01)])
  genes2.6 <- names(DE2.6[[i]][which(DE2.6[[i]] < 0.01)])
  genes2.8 <- names(DE2.8[[i]][which(DE2.8[[i]] < 0.01)])
  shared[[i]] <- intersect(intersect(genes2.4, genes2.6), genes2.8)
}

setwd("~/__Data/shelfLifeSLE")
save(shared, file="shelfLifeSLE_sharedGenesPerClusterDE2.4.6.8.RData")

setwd("~/__Data/shelfLifeSLE")
sharedSLE <- get(load("shelfLifeSLE_sharedGenesPerClusterDE2.4.6.8.RData"))
setwd("~/__Data")
sharedHD <- get(load("sharedGenesPerClusterDE2.4.6.8.RData"))

allDE <- intersect(unlist(sharedHD), unlist(sharedSLE))
sharedInCluster.HD.SLE <- lapply(sharedHD, function(x) intersect(x, allDE))
names(sharedInCluster.HD.SLE) <- paste0(names(sharedInCluster.HD.SLE), ":",
                                        c("Tnaive", "Mono", "Tact", "NK/Tgd", "B","pDC"))
sum(unlist(lapply(sharedInCluster.HD.SLE, length))) # 234
save(sharedInCluster.HD.SLE, file="~/__Data/shelfLifeSLE/sharedInCluster.HD.SLE_234Genes5CellTypes.RData")

setwd("~/__Data/")
save(shared, file="sharedGenesPerClusterDE2.4.6.8.RData")

setwd("~/__Data/shelfLifeSLE")
avExpList <- get(load("shelfLifeSLE_avExpList.RData"))

shared <- get(load("~/__Data/shelfLifeSLE/sharedInCluster.HD.SLE_234Genes5CellTypes.RData"))

M <- avExpList[["BRISL6:C4"]]
M <- M[intersect(shared[["cluster6:B"]], rownames(M)), ]
M <- M[apply(M, 1, sd) > 0, ]

setwd("~/__Plots")
pdf("shelfLife_SLE.BRISL6_DE2.4.6.8.18_cluster6Markers_heatmap.pdf")
library(pheatmap)
pheatmap(M, scale="row", cluster_cols=FALSE)
dev.off()

setwd("~/__Data")
targetsIFN <- read.csv("IFNtargets.csv", header=TRUE, as.is=TRUE)$Name
  
sort(intersect(unlist(shared), targetsIFN))
# "CCR1"    "DYNLT1"  "GCA"     "HSPA1A"  "JUN"     "MNDA"    "NAGK"    "SLFN5"   "TNFSF10"


##################################################################################################
####         per Adam's 27Sept2019 request for expression values as well as p-vals            ####
##################################################################################################

runDE2 <- function(time1, time2) {
  
   testDE2 <- function(x) {
     x1 <- x[grep(paste0("-", time1, "hr$"), names(x))]
     x2 <- x[grep(paste0("-", time2, "hr$"), names(x))]
     x1 <- x1[x1 > 0]
     x2 <- x2[x2 > 0]
     # Consider only clutsers with > 100 cells
     if (length(x1) > 100 & length(x2)>100) {
       pW <- wilcox.test(x1, x2)$p.value
       resTuplet <- c(T1=time1, T2=time2, medianT1=median(x1), medianT2=median(x2), 
                      meanT1=mean(x1), meanT2=mean(x2), maxT1=max(x1), maxT2=max(T2), P=pW)
       return(resTuplet)
     } else return(NULL)
   }

   clusterNos = 1:10
   res = NULL; N = 0
   resList = resLabels = list()
   Sys.time()
   for (cl in clusterNos) {
     i.CL <- grep(cl, CLs$group)
     clTbl <- normalizedPBMC[ , i.CL]
   
     stepSize = 1000
     M <- dim(clTbl)[1] - stepSize
     i1 = i2 = 0; res = NULL
     while (i2 < M) {
       i1 <- i2 + 1; i2 <- i2 + stepSize
       iTbl <- clTbl[i1:i2, ]
       res1 <- future_apply(iTbl, 1, FUN = testDE2)
       res1 <- do.call(rbind, res1)
       iCheck <- res1[ ,"P"] < 0.01 & !is.na(res1[ , "P"])
       if (length(iCheck) > 0) {
         res1 <- res1[iCheck, ]
         res <- rbind(res, res1)
       }
       print(i1)
     }
     
     remaining <- (i2+1):(dim(clTbl)[1])
     iTbl <- clTbl[remaining, ]
     genes <- rownames(iTbl)
     res2 <- future_apply(iTbl, 1, FUN = testDE2)
     res2 <- do.call(rbind, res2)
     iCheck <- res2[ ,"P"] < 0.01 & !is.na(res2[ , "P"])
     if (length(iCheck) > 0) {
       res2 <- res2[res2[ ,"P"] < 0.01 & !is.na(res2[ , "P"]), ]
       res <- c(res, res2)
     }
     if (!is.null(res)) {
        N <- N +1
        resList[[N]] <- res
        resLabels[[N]] <- paste0("cluster", cl)
        print(paste0("cluster ", cl, "  time:", Sys.time()))
     }
   }
   
   # res.adj <- lapply(resList, function(x) p.adjust(x, method="fdr")) 
   # NB. Previous method above only corrected for number of tests KEPT!
   res.adj <- lapply(resList, function(x) {
              x[ , "P"] <- x[ , "P"] * nrow(clTbl)
              return(x)
              })
   res.adj <- lapply(res.adj, function(x) {
                    x <- x[x[ ,"P"] < 0.05, ]
                    return(x)
              })
   res.adj <- lapply(res.adj, function(x) {
                    x <- x[order(x[ ,"P"]), ]
              })
   return(res.adj)
}

T1 = 2
for (T2 in c(4, 6, 8)) {
  print(Sys.time())
  res.adj <- runDE2(time1=T1, time2=T2)
  setwd("~/__Data/shelfLifeSLE")
  saveRDS(res.adj, file=paste0("shelfLifeSLE_DE", T1, "to", T2, "hr_adjFDR_details.CSV"))
  write.list(z=res.adj, 
             file=paste0("shelfLifeSLE_DE", T1, "to", T2, "hr_pVals_adjFDR_details.CSV"), 
             row.names=TRUE)
}


```

## Cell labeling

```{r labelCells}

library("tidyverse")
library("Matrix")

setwd("~/__Data")
timePoints <- HRs

library("Seurat")
pbmcTmp <- CreateSeuratObject(counts=normalizedPBMC, project="shelfLife", min.cells=3, 
                           min.features=200, meta.data=CLs)
Idents(pbmcTmp) <- paste0("C", CLs$group) # use cellRanger clusters

AdamLabels <- c(C1="C1:T cells, maybe naÃ¯ve", C2="C2:Monocytes", 
                C3="C3:NK/gdT/activated T cells", C4="C4:B cells", 
                C5="C5:Myeloid ?", C6="C6:DC/mac?", C7="C7:Hemoglobin+", 
                C8="C8:Ly6G+ PMN?", C9="C9:Ubiquitin+ Topoisomerase+ junk?", 
                C10="C10:pDC")

library(SingleCellExperiment)
pbmc.sce <- as.SingleCellExperiment(pbmcTmp)
indx <- match(colData(pbmc.sce)$ident, names(AdamLabels))
colData(pbmc.sce)$ident <- AdamLabels[indx]

rm(pbmcTmp)
gc()

setwd("~/__Data/signatures")
LM22 <- read.delim("CIBERSORT_LM22.txt", header=TRUE, row.names=1, as.is=TRUE) 
GSE107011 <- read.csv("PBMC_17of_29CellTypesRNAseqSignatures.csv", 
                      header=TRUE, row.names=1, as.is=TRUE) 
pmid30413720 <- read.csv('immunoStates_320Genes20CellTypes_signature.csv',
                         skip=2, header=TRUE, row.names=1, as.is=TRUE) # 20 cell types

library(Hmisc)
library(lsa)

# classSig: Set to one of: # LM22 # GSE107011 # pmid30413720

calcSigs <- function(classSig) {
  typesTbl = corrsTbl = list()
  for (i in 1:length(AdamLabels)) {
    iClust <- names(AdamLabels)[i]
    j <- which(colData(pbmc.sce)$ident == iClust)
    sharedGenes <- intersect(rownames(pbmc.sce), rownames(classSig))
  
    selExp <- as.matrix((counts(pbmc.sce))[sharedGenes, j])
    selSig <- as.matrix(classSig[sharedGenes, ])
    corrList <- future_apply(selExp, 2, FUN=function(y) rcorr(y, selSig))
    
    rList <- lapply(corrList, function(x) x$r)
    bestMatch <- unlist(lapply(rList, function(x) {
                      x[lower.tri(x, diag=TRUE)] <- NA
                      x <- x[1, -1]
                      return(names(which(x == max(x, na.rm=TRUE))))
                      }))
  
    bestCorr <- unlist(lapply(rList, function(x) {
                      x[lower.tri(x, diag=TRUE)] <- NA
                      x <- x[1, -1]
                      return( x[which(x == max(x, na.rm=TRUE))] )
                      }))
  
    matchTbl <- rev(sort(table(bestMatch)))
    typesTbl[[i]] <- matchTbl/sum(matchTbl)
    
    corrVals = NULL
    for (iCorr in 1:length(matchTbl)) {
      corrVals <- c(corrVals, median(bestCorr[grep(names(matchTbl)[iCorr], names(bestCorr))]))
    }
    corrsTbl[[i]] <- corrVals
  }
  names(typesTbl) <- AdamLabels
  names(corrsTbl) <- AdamLabels
  
  sigsList = list()
  for (A in 1:length(AdamLabels)) {
    DF <- data.frame("cell type"=typesTbl[[A]], "correlation to signature"=corrsTbl[[A]])
    sigsList[[A]] <- DF
  }
  return(sigsList)
}

allSigs = list(); loopCount = 0
mySigs <- list(LM22, GSE107011, pmid30413720)
for (signature in mySigs) {
  loopCount <- loopCount + 1
  print(paste0(Sys.time(), "    ", loopCount))
  allSigs[[loopCount]] <- calcSigs(classSig = signature)
}
names(allSigs) <- c("LM22", "GSE107011", "pmid30413720")

setwd("~/__Data/shelfLifeSLE")
save(allSigs, file="shelfLifeSLE_predictedCellTypes_fracCells_all3Sigs.RData")
# save(typesTbl, file="predictedCellTypes_fracCells_LM22.RData")
# save(corrsTbl, file="predictedCellTypes_medCorrs_LM22.RData")


library(ggrepel)
setwd("~/__Plots")
pdf("shelfLifeSLE_cellTypes2DPlot_allSigs.pdf", height=12, width=12)
for (indx in 1:length(AdamLabels)) {
    DF1 <- allSigs[[1]][[indx]]
    DF2 <- allSigs[[2]][[indx]]
    DF3 <- allSigs[[3]][[indx]]
    colnames(DF1)[2] = colnames(DF2)[2] = colnames(DF3)[2] = "fraction.of.cells"
    DF1$sig <- names(allSigs)[1]
    DF2$sig <- names(allSigs)[2]
    DF3$sig <- names(allSigs)[3]
    DF <- rbind(DF1, DF2, DF3)
    
    print(ggplot(DF, aes(fraction.of.cells, correlation.to.signature, label = cell.type.bestMatch, color=sig)) +
    geom_text_repel() +
    geom_point() +
    ggtitle(AdamLabels[indx]) +
    theme_classic(base_size = 16))
}
dev.off()


```

## Median expression per cluster for mFuzz

```{r avExpPerDonorPerTimepoint}
clusterNos = 1:10

Sys.time()
avExpList <- list(); indx = 0
for (i in IDs) {
  print(i)
  i.ID <- grep(i, colnames(normalizedPBMC))
  for (cl in clusterNos) {
     i.CL <- grep(cl, CLs$group)
     resMtrx = colID = NULL
     for (h in HRs) {
          i.HR <- grep(h, colnames(normalizedPBMC))
          j <- intersect(intersect(i.ID, i.HR), i.CL)
          if (length(j) > 2) { # skip clusters with few cells in this ID+HR
            resMtrx <- cbind(resMtrx, apply(normalizedPBMC[ , j], 1, median))
            colID <- c(colID, paste0(i, ":", "C", cl, ":", h))
          }
     }
     if (!is.null(resMtrx)) {
       colnames(resMtrx) <- colID
       indx <- indx + 1
       avExpList[[indx]] <- resMtrx
       names(avExpList)[indx] <- paste0(i, ":", "C", cl)
     }
  }
}
Sys.time()

selGenes <- lapply(avExpList, 
                   function(x) which(unlist(apply(x, 1, max)) > 1))
for (i in 1:length(selGenes)) {
  avExpList[[i]] <- avExpList[[i]][selGenes[[i]], ]
}

setwd("~/__Data/shelfLifeSLE")
save(avExpList, file="shelfLifeSLE_avExpList_noFilter.RData")
```

## Expression correlation

```{r correlationAnalysis}
library(Hmisc)
# corrList <- lapply(avExpList, function(x) {
#                   if (ncol(x) > 4) rcorr(t(x)) 
#                   })
# names(corrList)[lapply(corrList, length) == 0] # "BRISL2:C5" "BRISL2:C7"
# corrList <- corrList[lapply(corrList, length) > 0]
# setwd("~/__Data"); getwd()
# save(corrList, file="corrList.RData")
corrList <- get(load("corrList.RData"))

library(corrplot)
setwd("~/__Data/shelfLifeSLE"); getwd()
pdf("shelfLifeSLE_CorrPlots.pdf")
for (i in 1:length(corrList)) {
    x <- corrList[[i]]
    if (length(x) > 0) {
        x$P[which(is.na(x$P))] <- 1
        x$r[which(is.na(x$r))] <- 0
        x$r[x$r < -1 | x$r > 1] <- 0
        myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988", 
                              "#FFFFFF", "#77AADD", "#4477AA")))
        corrplot(x$r, type="upper", order="hclust", method="color",
                 p.mat = x$P, sig.level = 0.01, insig = "blank", 
                 col=myColors(200), diag=FALSE, tl.col="black", 
                 tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
                 mar = c(1, 1, 1, 1), hclust.method="complete")
    }
}
dev.off()

coExpMtrx = NULL
for (i in 1:length(corrList)) {
  x <- corrList[[i]]
  # Filter out unreliable P's:
  x$P[which(is.na(x$P))] <- 1
  x$P[which(is.nan(x$P))] <- 1
  x$P[which(is.na(x$r))] <- 1
  x$P[x$r < 0 | x$r > 1] <- 1
  coExpCount <- apply(x$P, 1, function(Y) length(which(Y < 0.01)))
  coExpMtrx <- rbind(coExpMtrx, coExpCount)
}
rownames(coExpMtrx) <- names(corrList)

library(pheatmap)
selGenes <- names(which(corrList[[3]]$P["CDC42", ] == 0))
mtrx <- avExpList[[names(corrList)[3]]][selGenes, ]
mtrx <- t(apply(mtrx, 1, scale))
colnames(mtrx) <- colnames(avExpList[[names(corrList)[3]]])
setwd("~/__Data/shelfLifeSLE"); getwd()
pdf("BRISL2.LoupeC3.corrCDC42.heatmap.pdf")
pheatmap(mtrx, cluster_cols=FALSE)
dev.off()

X <- avExpList[[names(corrList)[3]]][selGenes, ]
maxY <- max(X)
plot(c(1,5), c(0,maxY))
for (i in selGenes) {
  lines(X[i, ], col=rgb(0,0,0,0.25))
}


#### Correlation across all 3 donors:
setwd("~/__Data")
pdf("corrPlot_allClusters_allSamples.pdf")
for (cl in 1:10) {
  Q <- paste0(":C", cl, "$")
  subList <- avExpList[grep(Q, names(avExpList))]
  geneList <- lapply(subList, rownames)
  shared <- table(do.call(c, geneList))
  shared <- names(shared)[shared == 3]
  subList <- lapply(subList, function(x) x[shared, ])
  clusterExp <- do.call(cbind, subList)
  
  library(Hmisc)
  clusterCorr <- rcorr(t(clusterExp))
  
  corrMtrx <- clusterCorr$r
  corrMtrx[corrMtrx > 1] <- 0
  library(corrplot)
  myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988",
  "#FFFFFF", "#77AADD", "#4477AA")))
  corrplot(corrMtrx, type="upper", order="hclust", method="color",
          p.mat = x$P, sig.level = 0.05, insig = "blank",
          col=myColors(200), diag=FALSE, tl.col="black",
          tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
          mar = c(1, 1, 1, 1), hclust.method="ward.D2", main=
          paste0("Loupe Cell Type Cluster ", cl))
  }
dev.off()

###################################################################
#  For each donor, take median expression per gene per timepoint  #
###################################################################
# library(foreach)
# library(doParallel)
# HPC <- makeCluster(64)
# registerDoParallel(HPC)
# donor = avExp = NULL
# avExp <- foreach(ID = c("BRISL3", "BRISL4"), 
#                  hr = c("1h", "2h"), 
#                  CL = 1:3, 
#                  .combine = "rbind", .verbose = TRUE) %dopar% { 
#   indx <-  which(clusters$Cluster == CL)
#   cellType <- as.matrix(normalizedPBMC[ , indx])
#   donor <- cellType[ , grep(ID, colnames(cellType))]
#   donor <- apply(donor, 2, function(x) log2(x + 1))
#   selCols <- grep(hr, colnames(donor))
#   apply(donor[ , selCols], 1, median)
# }
# setwd("~/__Data"); getwd()
# save(avExp, file="avExpPerDonorPerTimepoint.RData")
```


```{r mFuzzCLustering}

setwd("~/__Data/shelfLifeSLE")
avExpList <- get(load("shelfLifeSLE_avExpList.RData"))

library(Mfuzz)
setwd("~/__Data/shelfLifeSLE")
pdf('shelfLifeSLE_mfuzzClusters.pdf')
allClusters = list()
for (i in 1:length(avExpList)) {
  eset <- ExpressionSet(avExpList[[i]])
  eset <- filter.std(eset, min.std = 0.1, visu = FALSE) 
  M <- mestimate(eset); M
  eset <- standardise(eset)
  cl <- mfuzz(eset, c=4, m=M)
  allClusters[[i]] <- cl
  shortName <- gsub("BRISL|C", "", names(avExpList)[i])
  tLabels <- paste0(shortName, ":", 
                    c("2", "4", "6", "8", "18")[1:ncol(avExpList[[i]])])
  mfuzz.plot(eset, cl=cl, mfrow=c(2, 2), new.window=FALSE,
  		   time.labels=tLabels,
  		   min.mem=0.5)
}
dev.off()
names(allClusters) <- names(avExpList)

setwd("~/__Data/shelfLifeSLE")
save(allClusters, file="shelfLifeSLE_all.mFuzz.clusters.RData")
# allClusters <- get(load("shelfLifeSLE_all.mFuzz.clusters.RData"))




selCL <- allClusters[[1]][[3]]
selGenes <- names(selCL[selCL == 4])

X <- avExpList[[names(allClusters)]][selGenes, ]
maxY <- max(X)
setwd("~/__Data/shelfLifeSLE")
pdf("BRISL2.LoupeC1.mFuzzCluster4_timeCourse.pdf")
plot(c(1,5), c(0,maxY), col=rgb(1,1,1,0), xaxt="n", 
     xlab="timepoint", ylab="Normalized log2 expression")
axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
for (i in 1:length(selGenes)) {
  lines(X[selGenes[i], ], col=i) # rgb(0,0,0,0.25)
}
dev.off()

# Get cluster member genes for visually-identified up in 4-6 hours clusters:
# BRISL2:C6   mFuzz cluster 1
# BRISL3:C6   mFuzz cluster 1
# BRISL4:C6   mFuzz cluster 2
B2C6 <- names(which(allClusters[["BRISL2:C6"]]["cluster"][[1]] == 1))
B3C6 <- names(which(allClusters[["BRISL3:C6"]]["cluster"][[1]] == 1))
B4C6 <- names(which(allClusters[["BRISL4:C6"]]["cluster"][[1]] == 2))
# intersect(intersect(B2C6, B3C6), B4C6) # empty
# sort(table(c(B2C6, B3C6, B4C6))) # REL == 2, IRF1 == 2

B2C7.1 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 1))
B2C7.4 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 4))
B3C7 <- names(which(allClusters[["BRISL3:C7"]]["cluster"][[1]] == 4))
B4C7 <- names(which(allClusters[["BRISL4:C7"]]["cluster"][[1]] == 3))
B2 <- unique(c(B2C7.1, B2C7.4))
sort(intersect(intersect(B2, B3C7), B4C7))
# "NACA"  "RPL31" "RPL35" "RPL36" "RPS19" "RPS21" "RPS26" "RPS29" "SRP14" "SUB1"
# The 7 RPL/RPS genes are involved in Ag presentation (as well as protein translation)

# pDCs == loupe cluster 10
B2C10 <- names(which(allClusters[["BRISL2:C10"]]["cluster"][[1]] == 2))
B3C10.1 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 1))
B3C10.2 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 2))
B4C10.2 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 2))
B4C10.4 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 4))
B3 <- unique(c(B3C10.1, B3C10.2))
B4 <- unique(c(B4C10.2, B4C10.4))
rev(sort(table(c(B2C10, B3, B4))))
# TRIR                   SPCS3                   SNRPB                  SEC11C 
#    3                       3                       3                       3
# TargetMine: cellular nitrogen compound metabolic process [GO:0034641]
# All 4 genes are associated with cd123+ plasmacytoid dcs 	BH-adjP=0.0175 

# Plot timecourse of AvExp of above 4 genes:
IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")
# genes.pDC <- c("TRIR","SPCS3", "SNRPB","SEC11C")
genes.pDC <- c("NACA","RPL31","RPL35","RPL36","RPS19","RPS21","RPS26","RPS29","SRP14","SUB1")
myColors <- c("cyan", "forestgreen", "red") 

setwd("~/__Data")
pdf("LoupeCluster7_genesAfftedAt4to6Hours_timeCourse.pdf")
par(mfrow=c(2,2))
for (g in genes.pDC) {
  expVals = NULL
  for (ID in IDs){
    expVals <- c(expVals, avExpList[[paste0(ID, ":C10")]][g, ])
  }
  MAX <- max(expVals)
  MIN <- min(expVals)
  plot(c(1, 5), c(MIN, MAX), xaxt='n', xlab="timepoint", 
       ylab="log2(normReads+1)", col="white", main=paste0(g))
  axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
  for (i in 1:length(IDs)) {
    vals <- avExpList[[paste0(IDs[i], ":C10")]][g, ]
    lines(1:5, vals, col=myColors[i], type='b')
  }
}
dev.off()

# Plot NFKBIA time course in B cells:
setwd("/home/hamid.bolouri/__Data/shelfLifeSLE/outs/analysis/clustering/kmeans_10_clusters/")
CLs <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(CLs$Barcode, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clusterIDs), ]
CLs$Barcode <- colnames(normalizedPBMC)

clustB <- CLs$Barcode[CLs$Cluster == 4]
iClustB <- match(clustB, colnames(normalizedPBMC))
iB2Hr <- intersect(grep("-2hr", colnames(normalizedPBMC)), iClustB)
iB4Hr <- intersect(grep("-4hr", colnames(normalizedPBMC)), iClustB)
iB6Hr <- intersect(grep("-6hr", colnames(normalizedPBMC)), iClustB)
iB8Hr <- intersect(grep("-8hr", colnames(normalizedPBMC)), iClustB)

hr2 <- normalizedPBMC["NFKBIA", iB2Hr]
hr4 <- normalizedPBMC["NFKBIA", iB4Hr]
hr6 <- normalizedPBMC["NFKBIA", iB6Hr]
hr8 <- normalizedPBMC["NFKBIA", iB8Hr]

DF <- data.frame(Time=c(rep("2Hr", length(iB2Hr)), rep("4Hr", length(iB4Hr)), 
                        rep("6Hr", length(iB6Hr)), rep("8Hr", length(iB8Hr))),
                 log2_NFKBIA=c(hr2, hr4, hr6, hr8))
library(ggplot2)
setwd("~/__Data/shelfLifeSLE")
pdf("SLE_LoupeCluster4Bcells.Violin2.4.6.8_NFKBIA.pdf")
ggplot(DF, aes(x=Time, y=log2_NFKBIA)) + 
  geom_violin(fill=rgb(0,0.5,1,0.15)) +
  geom_boxplot(width=0.1, color="darkred") +
  stat_summary(fun.y=median, geom="point", size=2, color="red")
dev.off()


###################### FHIT exploration for Miriam ########################
setwd("/home/hamid.bolouri/__Data/shelfLifeSLE/outs/analysis/clustering/kmeans_10_clusters/")
CLs <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(CLs$Barcode, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clusterIDs), ]
CLs$Barcode <- colnames(normalizedPBMC)

library(ggplot2)
setwd("~/__Data/shelfLifeSLE")
pdf("SLE_perCluster.Violin2.4.6.8.18_FHIT.pdf")
for (i in 1:10) {
  clustB <- CLs$Barcode[CLs$Cluster == i]
  iClustB <- match(clustB, colnames(normalizedPBMC))
  iB2Hr <- intersect(grep("-2hr", colnames(normalizedPBMC)), iClustB)
  iB4Hr <- intersect(grep("-4hr", colnames(normalizedPBMC)), iClustB)
  iB6Hr <- intersect(grep("-6hr", colnames(normalizedPBMC)), iClustB)
  iB8Hr <- intersect(grep("-8hr", colnames(normalizedPBMC)), iClustB)
  iB18Hr <- intersect(grep("-18hr", colnames(normalizedPBMC)), iClustB)
  
  hr2 <- normalizedPBMC["FHIT", iB2Hr]
  hr4 <- normalizedPBMC["FHIT", iB4Hr]
  hr6 <- normalizedPBMC["FHIT", iB6Hr]
  hr8 <- normalizedPBMC["FHIT", iB8Hr]
  hr18 <- normalizedPBMC["FHIT", iB18Hr]
  
  DF <- data.frame(Time=c(rep("2Hr", length(iB2Hr)), rep("4Hr", length(iB4Hr)),
                          rep("6Hr", length(iB6Hr)), rep("8Hr", length(iB8Hr)), 
                          rep("Hr18", length(iB18Hr)) ),
                   log2_FHIT=c(hr2, hr4, hr6, hr8, hr18))
  
  print(ggplot(DF, aes(x=Time, y=log2_FHIT)) +
    geom_violin(fill=rgb(0,0.5,1,0.15)) +
    geom_boxplot(width=0.1, color="darkred") +
    stat_summary(fun.y=median, geom="point", size=2, color="red"))
}
dev.off()

```

## HB: marker gene enrichment analysis 

```{r enrichment}
library(clusterProfiler)
library(gage)
library(pathview)

setwd("~/__Data/shelfLifeSLE")
DE.2.4 <- get(load("shelfLifeSLE_DE2to4hr_pVals_adjFDR_v2.RData"))
markersList <- lapply(DE.2.4, function(x) names(x)) 

keggPathways = NULL
for (i in 1:length(markersList)) {
  markerEGs <- id2eg(markersList[[i]])[ ,'ENTREZID']
  markerEGs <- markerEGs[!is.na(markerEGs)]

  keggE <- enrichKEGG(gene = markerEGs, organism = 'hsa', pvalueCutoff = 1) # NB p = 1

  indx <- which(keggE$qvalue < 0.05)
  if (length(indx > 0)) {
    iPathways <- data.frame(clusterNo=i, publishedLabel=names(DE.2.4)[i],
                            pathway=keggE$Description[indx],
                            pValue=keggE$qvalue[indx])
    keggPathways <- rbind(keggPathways, iPathways)
  }
  print(i)
}
setwd("~/__Data/shelfLifeSLE")
save(keggPathways, file="shelfLifeSLE_keggPathways_shelfLifeHD_DE2to4.RData")
write.csv(keggPathways, file="shelfLifeSLE_keggPathways_shelfLifeHD_DE2to4.CSV")
```



## Seurat general analyses

```{r pca,results='hide'}
setwd("~/__Data/shelfLifeSLE/")
pbmc <- get(load("seuratObj_pbmc_shelfLifeSLE.RData"))
pbmc <- RunPCA(object = pbmc, features = VariableFeatures(object = pbmc))
# names(pbmc) #  "RNA" "SCT" "pca"
# pbmc[['pca']]@feature.loadings[1:5,1:5] 
```

```{r pca_viz, message=TRUE}
# Examine and visualize PCA results a few different ways
# print(x = pbmc[['pca']], dims = 1:5, nfeatures = 5)
# VizDimLoadings(object = pbmc, dims = 1:2, reduction = 'pca')
# DimPlot(object = pbmc, reduction = 'pca')

# `DimHeatmap` can be useful when deciding which PCs to include. 
# Cells and features are ordered according to their PCA scores. 
# `cells` = 'a number' plots the 'extreme' cells on both ends of the spectrum, 
# which dramatically speeds plotting for large datasets. 

DimHeatmap(object = pbmc, dims = 1:15, cells = 500, balanced = TRUE)
```

### Determine the 'dimensionality' of the dataset

```{r jackstraw}
# NOTE: SLOW, comment out and use ElbowPlot()
# pbmc <- JackStraw(object = pbmc, num.replicate = 100)
# pbmc <- ScoreJackStraw(object = pbmc, dims = 1:20)
```

Use elbow plot instead:

```{r elbow_plot}
ElbowPlot(object = pbmc)
# choose 17 
```


### Cluster the cells

See [[SNN-Cliq, Xu and Su, Bioinformatics, 2015]](http://bioinformatics.oxfordjournals.org/content/early/2015/02/10/bioinformatics.btv088.abstract) and CyTOF data [[PhenoGraph, Levine *et al*., Cell, 2015]](http://www.ncbi.nlm.nih.gov/pubmed/26095251). 

To cluster the cells, can use the Louvain algorithm (default) or SLM [[SLM, Blondel *et al*., Journal of Statistical Mechanics]](http://dx.doi.org/10.1088/1742-5468/2008/10/P10008) via `FindClusters`.

A resolution parameter sets the 'granularity' of the downstream clustering (larger values, more clusters) ~ typical range 0.4-1.2 

The clusters can be found using the `Idents` function.


```{r cluster}
pbmc <- FindNeighbors(object = pbmc, dims = 1:17)
# resolution == 0.5 & PCs = 17 -> 39 clusters; PCs = 10 -> 33 clusters
# resolution == 0.25, PCs =  17 -> 28 clusters
# resolution == 0.1,  PCs =  17 -> 18 clusters
pbmc <- FindClusters(object = pbmc, resolution = 0.1)

# Assigned cluster numbers:     
clusterIDs <- Idents(object = pbmc)
length(table(clusterIDs))

save(clusterIDs, file="~/__Data/shelfLifeSLE/shelfLifeSLE_clusterIDs18.RData")

```

### Run non-linear dimensional reduction (UMAP/tSNE)

Use the same PCs as input to the clustering analysis.

```{r tsne}
# Install UMAP, via pip or reticulate::py_install(packages = "umap-learn")

# saveRDS(pbmc, "~/__Data/shelfLifeSLE/shelfLifeSLE_pbmc_SeuratObj_with18Clusters.rds")
pbmc <- readRDS("~/__Data/shelfLifeSLE/shelfLifeSLE_pbmc_SeuratObj_with18Clusters.rds")

pbmc <- RunUMAP(object = pbmc, dims = 1:17)
# Coords of UMMAP plot are in     pbmc[['umap']]@cell.embeddings

# Set `label = TRUE` or use the LabelClusters function for labeling
pdf("~/__Plots/shelfLifeSLE_UMAP.17PCs.18Clusters.pdf")
DimPlot(object = pbmc, reduction = 'umap', label = TRUE)
dev.off()

saveRDS(pbmc, file = 
        "~/__Data/shelfLifeSLE/shelfLifeSLE_pbmc_SeuratObj_18ClustersUMAP.rds")
umapCoords <- pbmc[['umap']]@cell.embeddings
save(umapCoords, 
     file="~/__Data/shelfLifeSLE/shelfLifeSLE_18ClusterUMAP.coords.RData")


plotCoords <- as.data.frame(umapCoords)
plotCoords$time <- "white"
plotCoords$time[grep("-2hr", rownames(plotCoords))] <- "2hr"
plotCoords$time[grep("-4hr", rownames(plotCoords))] <- "4hr" 
plotCoords$time[grep("-6hr", rownames(plotCoords))] <- "6hr" 
plotCoords$time[grep("-8hr", rownames(plotCoords))] <- "8hr" 
plotCoords$time[grep("-18hr", rownames(plotCoords))] <- "18hr"
plotCoords$time <- factor(plotCoords$time, levels=c("2hr", "4hr", "6hr", "8hr", "18hr"),
                          labels=c("2hr", "4hr", "6hr", "8hr", "18hr"))

myColors <- c("2hr"="blue", "4hr"="cyan", "6hr"="gold", "8hr"="magenta", "18hr"="orangered2")
library(ggplot2)
setwd("~/__Plots")
pdf("shelfLifeSLE_UMAP_18Clusters_byTimePoint.pdf")
ggplot(data=plotCoords, mapping = aes(x=UMAP_1, y=UMAP_2, color=time)) +
  geom_point(alpha=0.1) +
  scale_fill_manual(values = myColors, aesthetics = c("colour", "fill")) +
  theme(legend.key = element_rect(fill="white", color="white")) +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) 
dev.off()

```

### Finding differentially expressed features per cluster

"min.pct"
"max.cells.per.ident" will downsample each identity class to save time.

```{r markerAnalysis, fig.height=8, fig.width=15}
# find all markers of cluster 1
#cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
#head(x = cluster1.markers, n = 5)

# find all markers distinguishing cluster 5 from clusters 0 and 3
# cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(x = cluster5.markers, n = 5)

###################################################################################
# find markers for every cluster compared to all remaining cells:
# pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC) # top 2 +ve FC markers per cluster
# save(pbmc.markers, file="pbmc3k_markers.RData")

# see  [DE vignette](http://satijalab01.nygenome.org/seurat/v3.0/de_vignette.html) for more DE methods.

# cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 0, 
                                 # logfc.threshold = 0.25, test.use = "roc", 
                                 # only.pos = TRUE)
# 
# # `VlnPlot` == probability distributions across clusters)
# # `FeaturePlot` == feature expression on a tSNE or PCA plot)
# # See also `RidgePlot`, `CellScatter`, and `DotPlot`.
# 
# VlnPlot(object = pbmc, features = c("MS4A1", "CD79A"))
# # raw counts:
# VlnPlot(object = pbmc, features = c("NKG7", "PF4"), slot = 'counts', log = TRUE)
# FeaturePlot(object = pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", 
               # "FCGR3A", "LYZ", "PPBP", "CD8A"))

# `DoHeatmap` generates an expression heatmap for given cells and features. 

# pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC) -> top10
# DoHeatmap(object = pbmc, features = top10$gene) + NoLegend()

# new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", 
                     # "FCGR3A+ Mono", "NK", "DC", "Mk", "blob")
# names(x = new.cluster.ids) <- levels(x = pbmc)
# pbmc <- RenameIdents(object = pbmc, new.cluster.ids)
# DimPlot(object = pbmc, reduction = 'umap', label = TRUE, pt.size = 0.5) + NoLegend()

# library(ggplot2)
# plot <- DimPlot(object = pbmc, reduction = "umap", label = TRUE, label.size = 4.5) + xlab("UMAP 1") + ylab("UMAP 2") + 
#   theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + 
 #  guides(colour = guide_legend(override.aes = list(size = 10)))
# ggsave(filename = "~/Desktop/filtered_gene_bc_matrices/hg19/pbmc3k_umap.png", height = 7, width = 12, plot = plot)
```


```{r etc}
# First, in the "Compute engine console", use the SSH button to bring up a shell and install these:
sudo apt-get install libcurl4-openssl-dev
sudo apt-get install libssl-dev

# Then in R, run:
install.packages('Seurat', repos="https://cloud.r-project.org")
install.packages("liger")
linstall.packages("knitr")

````
