---
title: "cellHashing_miSeq"
author: "HB"
date: "6/20/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Allocate memory  and use all CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 8)
options(future.globals.maxSize = 20 * 1024 ^ 3)

library("future.apply")
library("stats")
# future_lapply(1:10, FUN = quantile, probs = 1:3/4)
```

#############################################################
## https://satijalab.org/seurat/v3.0/hashing_vignette.html ##
#############################################################

```{r main}
library(Seurat)
library(Matrix)

# Load in the UMI matrix
pbmc.umis <- Read10X("~/__Data/cellHashing/cellRanger_miseq/filtered_feature_bc_matrix/")

# To generate a hashtag count matrix from FASTQ files, see
# https://github.com/Hoohm/CITE-seq-Count.  
# Load in the HTO count matrix
setwd("~/__Data/cellHashing")
pbmc.htos <- read.csv("CITEseqCount_res_D703.csv", row.names=1, as.is=TRUE)
pbmc.htos <- pbmc.htos[!grepl("bad_struct|no_match|total_reads", rownames(pbmc.htos)), ]

# Select cell barcodes detected by both RNA and HTO:
joint.bcs <- intersect(colnames(pbmc.umis), colnames(pbmc.htos)) # 8962

# Subset RNA and HTO counts by joint cell barcodes
pbmc.umis <- pbmc.umis[, joint.bcs]
pbmc.htos <- as.matrix(pbmc.htos[, joint.bcs])

# Confirm that the HTO have the correct names
rownames(pbmc.htos)


# Setup Seurat object
pbmc.hashtag <- CreateSeuratObject(counts = pbmc.umis)

# Normalize RNA data with log normalization
pbmc.hashtag <- NormalizeData(pbmc.hashtag)
# Find and scale variable features
pbmc.hashtag <- FindVariableFeatures(pbmc.hashtag, selection.method = "mean.var.plot")
pbmc.hashtag <- ScaleData(pbmc.hashtag, features = VariableFeatures(pbmc.hashtag))


# Add HTO data as a new assay independent from RNA
pbmc.hashtag[["HTO"]] <- CreateAssayObject(counts = pbmc.htos)
# Normalize HTO data, here we use centered log-ratio (CLR) transformation
pbmc.hashtag <- NormalizeData(pbmc.hashtag, assay = "HTO", normalization.method = "CLR")

# If you have a very large dataset we suggest using k_function = 'clara'. This is a k-medoid
# clustering function for large applications You can also play with additional parameters (see
# documentation for HTODemux()) to adjust the threshold for classification Here we are using the
# default settings
pbmc.hashtag <- HTODemux(pbmc.hashtag, assay = "HTO", positive.quantile = 0.99)

# Global classification results
table(pbmc.hashtag$HTO_classification.global)
 # Doublet Negative  Singlet 
 #    1138       16     7808 

# Group cells based on the max HTO signal
Idents(pbmc.hashtag) <- "HTO_maxID"
RidgePlot(pbmc.hashtag, assay = "HTO", features = rownames(pbmc.hashtag[["HTO"]])[1:2], ncol = 2)

# Visualize pairs of HTO signals to confirm mutual exclusivity in singlets
FeatureScatter(pbmc.hashtag, feature1 = "hto_POP1", feature2 = "hto_POP2")

# Compare number of UMIs for singlets, doublets and negative cells
Idents(pbmc.hashtag) <- "HTO_classification.global"
VlnPlot(pbmc.hashtag, features = "nCount_RNA", pt.size = 0.1, log = TRUE)

# Generate a tSNE embedding for HTOs. ere, grouping cells by singlets and doublets

# First, we will remove negative cells from the object
pbmc.hashtag.subset <- subset(pbmc.hashtag, idents = "Negative", invert = TRUE)

# Calculate a distance matrix using HTO
hto.dist.mtx <- as.matrix(dist(t(GetAssayData(object = pbmc.hashtag.subset, assay = "HTO"))))

# Calculate tSNE embeddings using above distance matrix
pbmc.hashtag.subset <- RunTSNE(pbmc.hashtag.subset, distance.matrix = hto.dist.mtx, perplexity = 100)
DimPlot(pbmc.hashtag.subset)

# Create an HTO heatmap, based on Figure 1C in the Cell Hashing paper.

# To increase the efficiency of plotting, you can subsample cells using the num.cells argument
HTOHeatmap(pbmc.hashtag, assay = "HTO", ncells = 5000)


# Cluster and visualize cells using the usual scRNA-seq workflow

# Extract the singlets
pbmc.singlet <- subset(pbmc.hashtag, idents = "Singlet")

# Select the top 1000 most variable features
pbmc.singlet <- FindVariableFeatures(pbmc.singlet, selection.method = "mean.var.plot")

# Scaling RNA data, we only scale the variable features here for efficiency
pbmc.singlet <- ScaleData(pbmc.singlet, features = VariableFeatures(pbmc.singlet))

# Run PCA
# pbmc.singlet <- RunPCA(pbmc.singlet, features = VariableFeatures(pbmc.singlet))
# PC_ 1 
# Positive:  LYZ, S100A9, S100A8, FCN1, VCAN, CD14, AIF1, MNDA, TYMP, MS4A6A 
# 	   AC020656.1, PSAP, S100A12, CFD, GRN, NCF2, LST1, FCER1G, CD68, LGALS2 
# 	   KLF4, FTL, FGL2, TKT, CLEC12A, TNFAIP2, IGSF6, LGALS3, CEBPD, SERPINA1 
# Negative:  RPS6, RPL32, MT-ATP6, CD7, CD247, CCL5, NKG7, GZMA, CTSW, GNLY 
# 	   RORA, SYNE2, CST7, CD69, CD8B, CD8A, GZMK, GZMH, PRF1, GZMB 
# 	   KLRD1, DUSP2, HOPX, FGFBP2, MATK, KLRG1, LYAR, TRGC2, CCL4, RETREG1 
# PC_ 2 
# Positive:  CD79A, IGHM, MS4A1, HLA-DRA, CD79B, IGKC, BANK1, HLA-DQA1, IGHD, HLA-DPB1 
# 	   HLA-DPA1, TCL1A, LINC00926, HLA-DQB1, RALGPS2, TNFRSF13C, IGLC2, BLK, SPIB, IGLC3 
# 	   HLA-DRB5, HLA-DRB1, TCF4, BCL11A, CD22, P2RX5, IRF8, CD24, HLA-DMB, FAM129C 
# Negative:  NKG7, GNLY, CCL5, GZMB, CST7, GZMH, FGFBP2, GZMA, PRF1, KLRD1 
# 	   CTSW, KLRF1, HOPX, FCGR3A, SPON2, CLIC3, CCL4, TRDC, CD247, ADGRG1 
# 	   MATK, EFHD2, ID2, CMC1, KLRC2, PRSS23, PTGDR, IL2RB, FCRL6, TTC38 
# PC_ 3 
# Positive:  RPL32, RPS6, VIM, S100A8, S100A9, MT-ND3, S100A12, VCAN, AIF1, IL6ST 
# 	   LYZ, CD14, FCN1, RETREG1, ADTRP, FHIT, EPHX2, MT-ND1, LINC01550, CMTM8 
# 	   AC020656.1, AC005842.1, RBP7, CITED4, TBC1D4, PASK, MNDA, CD5, PLBD1, JAML 
# Negative:  NKG7, GNLY, GZMB, CST7, FGFBP2, GZMH, HLA-DPB1, CD79A, HLA-DPA1, CCL5 
# 	   IGHM, MS4A1, PRF1, GZMA, KLRD1, HLA-DRA, HLA-DQA1, CD79B, IGKC, FCGR3A 
# 	   KLRF1, HOPX, BANK1, CLIC3, SPON2, CTSW, CCL4, IGHD, CXXC5, HLA-DQB1 
# PC_ 4 
# Positive:  MT-CO2, TCL1A, IGHM, MT-CO1, GNLY, FGFBP2, IGHD, MT-ND3, GZMH, MT-ATP6 
# 	   GZMB, MT-ND1, S100A8, NKG7, MS4A1, CST7, LINC00926, S100A12, S100A9, CCL5 
# 	   CD79A, KLRD1, KLRF1, PRF1, BANK1, VCAN, CD22, SPON2, CCL4, HLA-DRA 
# Negative:  MZB1, ACTG1, VIM, JCHAIN, ITM2C, RPS6, PTTG1, IGHA1, FABP5, FUT7 
# 	   RPL32, NPDC1, SMC4, IGHG3, PDIA4, DCPS, LAP3, TNFRSF4, RORA, CRELD2 
# 	   LMNA, STMN1, CD59, MAN1A1, ISG15, PHF19, CDK6, PCNA, TIMM17A, TXNDC15 
# PC_ 5 
# Positive:  CDKN1C, MS4A7, IFITM3, FCGR3B, FCGR3A, LRRC25, IFI30, MTSS1, PILRA, CSF1R 
# 	   LILRB2, HMOX1, LST1, MAFB, WARS, SPI1, SERPINA1, ABI3, CD300E, SLC2A6 
# 	   FCER1G, PIK3AP1, MT-ATP6, CAMK1, RRAS, ITGAX, MAPKAPK3, PAK1, SH2D3C, C15orf39 
# Negative:  S100A12, MZB1, S100A8, JCHAIN, RBP7, PLBD1, VCAN, S100A9, IGHA1, CES1 
# 	   ITM2C, CD14, CYP1B1, PADI4, QPCT, ITGAM, MGST1, AC020656.1, MNDA, CSTA 
# 	   CSF3R, PDIA4, CKAP4, PGD, MAN1A1, CLEC4E, CRISPLD2, IGLC2, SLC2A3, NCF1 

# We select the top 10 PCs for clustering and tSNE based on PCElbowPlot
pbmc.singlet <- FindNeighbors(pbmc.singlet, reduction = "pca", dims = 1:10)
pbmc.singlet <- FindClusters(pbmc.singlet, resolution = 0.6)

pbmc.singlet <- RunTSNE(pbmc.singlet, reduction = "pca", dims = 1:10)

# Projecting singlet identities on TSNE visualization
DimPlot(pbmc.singlet, group.by = "HTO_classification")


```


```