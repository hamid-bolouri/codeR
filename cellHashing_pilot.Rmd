---
title: "cellHashing_miSeq"
author: "HB"
date: "6/20/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Allocate memory  and use all CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 64)
options(future.globals.maxSize = 20 * 1024 ^ 3)

library("future.apply")
library("stats")
```

#############################################################
## https://satijalab.org/seurat/v3.0/hashing_vignette.html ##
#############################################################

```{r main}
Sys.time()

library(Seurat)
library(Matrix)

runID = "P80"

# Load in the UMI matrix
pbmc.umis <- Read10X("/home/hamid.bolouri/__Data/cellHashing/count/Pool-80/outs/filtered_feature_bc_matrix")

pbmc.htos <- readMM("/home/hamid.bolouri/__Data/cellHashing/CITE-seq/Pool-80-HTO/umi_count/matrix.mtx.gz")
barcodes <- read.delim("/home/hamid.bolouri/__Data/cellHashing/CITE-seq/Pool-80-HTO/umi_count/barcodes.tsv.gz",
                       header=FALSE, as.is=TRUE)$V1
umis <- read.delim("/home/hamid.bolouri/__Data/cellHashing/CITE-seq/Pool-80-HTO/umi_count/features.tsv.gz",
                       header=FALSE, as.is=TRUE)$V1
colnames(pbmc.htos) <- barcodes
rownames(pbmc.htos) <- umis

# Select cell barcodes detected by both RNA and HTO:
joint.bcs <- intersect(colnames(pbmc.umis), colnames(pbmc.htos)) # 8962

# Subset RNA and HTO counts by joint cell barcodes
pbmc.umis <- pbmc.umis[, joint.bcs]
pbmc.htos <- as.matrix(pbmc.htos[, joint.bcs])

# Check that the HTO have the correct names
# rownames(pbmc.htos)


# Setup Seurat object
pbmc.hashtag <- CreateSeuratObject(counts = pbmc.umis)

# Normalize RNA data with log normalization
pbmc.hashtag <- NormalizeData(pbmc.hashtag)
# Find and scale variable features
pbmc.hashtag <- FindVariableFeatures(pbmc.hashtag, selection.method = "mean.var.plot")
pbmc.hashtag <- ScaleData(pbmc.hashtag, features = VariableFeatures(pbmc.hashtag))


# Add HTO data as a new assay independent from RNA
pbmc.hashtag[["HTO"]] <- CreateAssayObject(counts = pbmc.htos)
# Normalize HTO data, using centered log-ratio (CLR) transformation
pbmc.hashtag <- NormalizeData(pbmc.hashtag, assay = "HTO", normalization.method = "CLR")

# For very large dataset we suggest using k_function = 'clara'
pbmc.hashtag <- HTODemux(pbmc.hashtag, assay = "HTO", positive.quantile = 0.99,
                         seed = 123)

# Global classification results
doubletRateTbl <- table(pbmc.hashtag$HTO_classification.global)
 # Doublet Negative  Singlet 
 #    1138       16     7808 
setwd("~/__Data/cellHashing")
save(doubletRateTbl, file=paste0(runID, "_doubletRate.RData"))


# Group cells based on the max HTO signal
Idents(pbmc.hashtag) <- "HTO_maxID"
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_maxHTO_RidgePlot.pdf"), height=15, width=15)
RidgePlot(pbmc.hashtag, assay = "HTO", features = rownames(pbmc.hashtag[["HTO"]])[1:6], ncol = 2)
dev.off()

# Visualize pairs of HTO signals to confirm mutual exclusivity in singlets
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_featureScatterPlot.pdf"), height=7, width=12)
FeatureScatter(pbmc.hashtag, feature1 = "POP1-GTCAACTCTTTAGCG", feature2 = "POP2-TGATGGCCTATTGGG")
dev.off()

# Compare number of UMIs for singlets, doublets and negative cells
Idents(pbmc.hashtag) <- "HTO_classification.global"
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_nUMIs_doubletsEtcVlnPlot.pdf"))
VlnPlot(pbmc.hashtag, features = "nCount_RNA", pt.size = 0.1, log = TRUE)
dev.off()


# Generate a tSNE embedding for HTOs. Here, grouping cells by singlets and doublets

# First, we will remove negative cells from the object
# pbmc.hashtag.subset <- subset(pbmc.hashtag, idents = "Negative", invert = TRUE)

# Calculate a distance matrix using HTO
# hto.dist.mtx <- as.matrix(dist(t(GetAssayData(object = pbmc.hashtag.subset, assay = "HTO"))))
hto.dist.mtx <- as.matrix(dist(t(GetAssayData(object = pbmc.hashtag, assay = "HTO"))))

# Calculate tSNE embeddings using above distance matrix
# pbmc.hashtag.subset <- RunTSNE(pbmc.hashtag.subset, distance.matrix = hto.dist.mtx, perplexity = 100)
pbmc.hashtag <- RunTSNE(pbmc.hashtag, distance.matrix = hto.dist.mtx, perplexity = 100)
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_hashtag_tSNE.pdf"))
DimPlot(pbmc.hashtag)
dev.off()

# Create an HTO heatmap, based on Figure 1C in the Cell Hashing paper.

# To increase the efficiency of plotting, you can subsample cells using the num.cells argument
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_heatmapHTO.pdf"))
HTOHeatmap(pbmc.hashtag, assay = "HTO", ncells = 5000)
dev.off()

# Cluster and visualize cells using the usual scRNA-seq workflow

# Extract the singlets
pbmc.singlet <- subset(pbmc.hashtag, idents = "Singlet")

# Select the top 1000 most variable features
pbmc.singlet <- FindVariableFeatures(pbmc.singlet, selection.method = "mean.var.plot")

# Scaling RNA data, we only scale the variable features here for efficiency
pbmc.singlet <- ScaleData(pbmc.singlet, features = VariableFeatures(pbmc.singlet))


# We select the top 10 PCs for clustering and tSNE based on PCElbowPlot
pbmc.singlet <- RunPCA(pbmc.singlet, features = VariableFeatures(pbmc.singlet))
pbmc.singlet <- FindNeighbors(pbmc.singlet, reduction = "pca", dims = 1:10)
pbmc.singlet <- FindClusters(pbmc.singlet, resolution = 0.6)

pbmc.singlet <- RunTSNE(pbmc.singlet, reduction = "pca", dims = 1:10)

# Projecting singlet identities on TSNE visualization
setwd("~/__Data/cellHashing")
pdf(paste0(runID, "_tSNE_clusters.pdf"), height=7, width=12)
DimPlot(pbmc.singlet, group.by = "HTO_classification")
dev.off()

Sys.time()

```

