---
title: "Seurat 3.0 - Guided Clustering Tutorial - HB version"
output:
  html_document:
    theme: united
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```

### Allocate memory  and use all CPUs

```{r}
library(future)
plan(strategy = "multiprocess", workers = 96)
options(future.globals.maxSize = 20 * 1024 ^ 3)

library("future.apply")
library("stats")
# future_lapply(1:10, FUN = quantile, probs = 1:3/4)
```

### Refs

Based on https://www.dropbox.com/s/38h5zccv0b7l9pr/pbmc3k_tutorial.Rmd?dl=1

See also: https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html

Data can be found [here](https://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz).
`Seurat` object wiki [GitHub Wiki](https://github.com/satijalab/seurat/wiki). 

The count matrix is stored in `pbmc[["RNA"]]@counts`.

```{r init}
library(dplyr)
library(Seurat)

# Load the PBMC dataset
setwd("~/__Data")
dir()
load("Aggr_Human_Immunology_RTX-850_GRCh38-3.0.0_mat_v3_reads.RData")

################## Testing SCTransform outside of Seurat ########################################
# library(sctransform)
# vst_out <- vst(mat, return_cell_attr = TRUE, show_progress = TRUE) # 171 GB !!!
# umi_corrected <- correct_counts(vst_out, mat) # needed min 200GB of RAM



################## tmp fix ######################################################################
# i = grep("2h$", colnames(mat))
# mat <- mat[ ,i[1:1000]]
#################################################################################################

# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = mat, project = "pbmcAging", min.cells = 3, min.features = 200)
rm(mat)
gc()
# pbmc # 24796 features across 136068 samples within 1 assay 
```

```{r}
# examine a few genes in the first thirty cells
# pbmc.data[c("CD3D","TCL1A","MS4A1"), 1:30]
```

```{r mito, fig.height=7, fig.width=13}
# The [[.]] operator can add columns to object metadata 
pbmc[["percent.mt"]] <- PercentageFeatureSet(object = pbmc, pattern = "^MT-")
hist(unlist(pbmc[["percent.mt"]]), breaks=50, col="skyblue", main="",
     border="white", xlab="Percentage of genes that are mitochondrial") # long tail past 20% MT

IDs <-rownames(pbmc@meta.data)
IDs <- strsplit(IDs, "-")
donors <- unlist(lapply(IDs, function(x) x[2]))
timePoints <- unlist(lapply(IDs, function(x) x[3]))
timePoints[timePoints == "18h"] <- "hr18"
plotPoints <- data.frame(pbmc[["percent.mt"]], TimePoint=timePoints)

# library(beeswarm)
# beeswarm(plotPoints)

library(ggplot2) # , fill=TimePoint
theme_update(text = element_text(size=20))
ggplot(plotPoints, aes(x=TimePoint, y=percent.mt, color=TimePoint)) + 
geom_violin() +
stat_summary(fun.data=mean_sdl, mult=1, 
             geom="pointrange", color=rgb(0,0,0,1)) +
theme(axis.text.x = element_text(size = 20), 
      axis.text.y = element_text(size = 20))

```

```{r qc, fig.height=7, fig.width=13}
# Show QC metrics for the first 5 cells
head(x = pbmc@meta.data, 5)
```

```{r qc2, fig.height=7, fig.width=13}

#Visualize QC metrics as a violin plot
VlnPlot(object = pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3, pt.size = 0)

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(object = pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
CombinePlots(plots = list(plot1,plot2))

pbmc <- subset(x = pbmc, subset = nFeature_RNA > 500 & nFeature_RNA < 6000 & percent.mt < 15)
gc()
```

### Normalizing the data

Default is a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression. Normalized values are stored in `pbmc[["RNA"]]@data`.

```{r normalize}
# Not run. See scTransform below.
# pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 1e4)
```

```{r var_features, fig.height=5, fig.width=11}
pbmc <- FindVariableFeatures(object = pbmc,selection.method = 'vst', nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(x = VariableFeatures(object = pbmc), 10)
top500 <- head(x = VariableFeatures(object = pbmc), 500)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(object = pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1 , plot2))
```

### Scaling the data

Counts -> Z-scores for PCA, etc.

```{r regress, fig.height=7, fig.width=11, results='hide'}
# Old Seurat approach to normalization & scaling with individual commands:
# all.genes <- rownames(x = pbmc)

# 'vars.to.regress' filters out bad cells:
# pbmc <- ScaleData(object = pbmc, features = all.genes)
```

However, `sctransform` is the new recommended method and comes with a `vars.to.regress` parameter.

```{r scaling and normalization, results='hide'}
gc()
pbmc <- SCTransform(object = pbmc, verbose = FALSE, vars.to.regress = 'percent.mt', conserve.memory = TRUE)
# Transformed data will be available in the SCT assay, 
# which is set as the default after running sctransform

# names(pbmc) #  "RNA" "SCT" 
normalizedPBMC <- GetAssayData(object = pbmc, assay="SCT", slot = "data")
setwd("~/__Data")
# getwd()
save(normalizedPBMC, file="SeuratNormalizedCounts_GRCh38_filteredMT.RData")
# nonZeros <- as.matrix(normalizedPBMC); nonZeros <- nonZeros[(nonZeros > 0)]
# hist(nonZeros, breaks=10) # nothing above ~5.5, most values between 1 and 2.
```

### Try Celaref #################################################

```{r tryCelaref}
setwd("~/__Data"); getwd()
normalizedPBMC <- get(load("SeuratNormalizedCounts_GRCh38_filteredMT.RData"))

#### NB: Subsetting normalizedPBMCs ######################################################

normalizedPBMC <- normalizedPBMC[ , grep("BRISL3", colnames(normalizedPBMC))]
normalizedPBMC <- normalizedPBMC[ , grep("-2h$", colnames(normalizedPBMC))] # 8564 cells

PBMC.IDs <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[1]))
 
# setwd("~/__Data")
# writeMM(normalizedPBMC, file="normalizedPBMC.mtx")

setwd("~/__Data"); getwd()
CLs <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(CLs$Barcode, "-"), function(x) x[1]))
CLs <- CLs[match(PBMC.IDs, clusterIDs), ]
CLs$Barcode <- colnames(normalizedPBMC)
colnames(CLs) <- c("ID", "group")
CLs$group<- as.factor(CLs$group)
library(S4Vectors)
CLs <- DataFrame(CLs)
# setwd("~/__Data")
# write.table(CLs, file="clustersForCelaref.tsv", sep="\t", row.names=FALSE, col.names=TRUE)

library("celaref")
library("Matrix")
library("SummarizedExperiment")
# selIndx <- sample(1:dim(normalizedPBMC)[2], 75000)
# tmp <- as.matrix(normalizedPBMC[ , selIndx])
# dataset_se <- SummarizedExperiment(tmp)
# rm(tmp); gc()
# colData(dataset_se) <- CLs[selIndx, ]

dataset_se <- SummarizedExperiment(normalizedPBMC)
rowData(dataset_se)$ID <- rownames(normalizedPBMC)
names(assays(dataset_se)) <- "counts"

de_table <- contrast_each_group_to_the_rest(dataset_se=dataset_se, 
                                            dataset_name="shelfLifeDE", 
                                            num_cores=16)
setwd("~/__Data")
save(de_table, file="de_table_75K.normalizedPBMC.RData")

library("readr")
setwd("~/__Data"); getwd()
norm_expression_table.full <- read.table("Watkins_expression.txt", 
                                         sep="\t", header=TRUE, quote="", 
                                         comment.char="", row.names=1, check.names=FALSE)
setwd("~/__Data"); getwd()
samples_table <- read_tsv("Watkins_samples.txt", col_types = cols())
samples_table$description  <- make.names(samples_table$description)

library("tidyverse")
library("illuminaHumanv2.db")
# probes_with_gene_symbol_and_with_data <- intersect(keys(illuminaHumanv2SYMBOL),
#                                                    rownames(norm_expression_table.full))
# probe_to_symbol <- select(illuminaHumanv2.db, keys=rownames(norm_expression_table.full), 
#                           columns=c("SYMBOL"), keytype="PROBEID")
# probe_to_symbol <- unique(probe_to_symbol[! is.na(probe_to_symbol$SYMBOL),])
# genes_per_probe <- table(probe_to_symbol$PROBEID) 
# multimap_probes <- names(genes_per_probe)[genes_per_probe  > 1]
# probe_to_symbol <- probe_to_symbol[!probe_to_symbol$PROBEID %in% multimap_probes, ]
# 
# convert_expression_table_ids<- function(expression_table, the_probes_table, old_id_name, new_id_name){
#     the_probes_table <- the_probes_table[,c(old_id_name, new_id_name)]
#     colnames(the_probes_table) <- c("old_id", "new_id")
#     probe_expression_levels <- rowSums(expression_table)
#     the_probes_table$avgexpr <- probe_expression_levels[as.character(the_probes_table$old_id)]
#     the_genes_table <-  the_probes_table %>% 
#         group_by(new_id) %>%
#         top_n(1, avgexpr)
#     expression_table <- expression_table[the_genes_table$old_id,]
#     rownames(expression_table) <- the_genes_table$new_id
#     return(expression_table)
# }
# norm_expression_table.genes <- convert_expression_table_ids(norm_expression_table.full, 
#                                                             probe_to_symbol, old_id_name="PROBEID", 
#                                                             new_id_name="SYMBOL")
# 
# library(limma)
# de_table.Watkins2009PBMCs <- contrast_each_group_to_the_rest_for_norm_ma_with_limma(
#                  norm_expression_table = norm_expression_table.genes, 
#                  sample_sheet_table    = samples_table, 
#                  dataset_name          = "Watkins2009PBMCs", 
#                  extra_factor_name     = 'description', 
#                  sample_name           = "sampleId",
#                  group_name            = 'celltype')

setwd("~/__Data")
# save(de_table.Watkins2009PBMCs, file="de_table.Watkins2009PBMCs.RData")
de_table.Watkins2009PBMCs <- get(load("de_table.Watkins2009PBMCs.RData"))

# tmp = get_the_up_genes_for_all_possible_groups(de_table.test=de_table, 
#                                                de_table.ref=de_table.Watkins2009PBMCs,
#                                                rankmetric="TOP100_SIG")

make_ranking_violin_plot(de_table.test=de_table, de_table.ref=DE.Watkins,
                         rankmetric="TOP100_SIG")
group_names_table <- make_ref_similarity_names(de_table, DE.Watkins, rankmetric="TOP100_SIG")
```

### Pathway analysis

```{r avExpPerDonorPerTimepoint}
setwd("~/__Data"); getwd()
normalizedPBMC <- get(load("SeuratNormalizedCounts_GRCh38_filteredMT.RData"))
PBMC.IDs <- unlist(lapply(strsplit(colnames(normalizedPBMC), "-"), function(x) x[1]))

#### Look for genes DE across timepoints
testDE <- function(x) {
  #x <- as.vector(x)
  x1 <- x[grep("-4h$", names(x))]
  x2 <- x[grep("-6h$", names(x))]
  x1 <- x1[x1 > 0]
  x2 <- x2[x2 > 0]
  if (length(x1) > 100 & length(x2)>100) {
    wilcox.test(x1, x2)$p.value
  }
}

setwd("~/__Data"); getwd()
clusters <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(clusters$Barcode, "-"), function(x) x[1]))
clusters <- clusters[match(PBMC.IDs, clusterIDs), ]

IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")
CLs = 1:10
resList = list()
Sys.time()
for (cl in CLs) {
  i.CL <- grep(cl, clusters$Cluster)
  clTbl <- normalizedPBMC[ , i.CL]

  stepSize = 1000
  M <- dim(clTbl)[1] - stepSize
  i1 = i2 = 0; res = NULL
  while (i2 < M) {
    i1 <- i2 + 1; i2 <- i2 + stepSize
    tmp <- unlist(future_apply(clTbl[i1:i2, ], 1, FUN = testDE))
    tmp <- tmp[tmp < 0.01 & !is.na(tmp)]
    res <- c(res, tmp)
    print(i1)
  }
  
  remaining <- (i2+1):(dim(clTbl)[1])
  res2 <- unlist(future_apply(clTbl[remaining, ], 1, FUN = testDE))
  res2 <- res2[res2 < 0.01 & !is.na(res2)]
  res <- c(res, res2)
  resList[[cl]] <- res
  print(paste0("cluster ", cl, "  time:", Sys.time()))
}

res.adj <- lapply(resList, function(x) p.adjust(x, method="fdr")) 
res.adj <- lapply(res.adj, sort)
names(res.adj) <- paste0("cluster", 1:10)
res.adj <- res.adj[which(unlist(lapply(res.adj, length) > 0))]
DE2to4Hr.pAdj <- lapply(res.adj, function(x) names(x)[x < 0.01])
  
setwd("~/__Data")
save(res.adj, file="DE4to6hr_pVals_adjFDR.RData")
library(erer)
setwd("~/__Data")
write.list(z=res.adj, file="DE4to6Hr.pAdj.csv", row.names=TRUE)

clusterNo = 6
indx1 <- intersect(grep("4h$", colnames(normalizedPBMC)),
                   grep(clusterNo, clusters$Cluster))
indx2 <- intersect(grep("6h$", colnames(normalizedPBMC)),
                   grep(clusterNo, clusters$Cluster))
hr2 <- normalizedPBMC["NFKBIA", indx1]
hr4 <- normalizedPBMC["NFKBIA", indx2]
DF <- data.frame(Time=c(rep("hr4", length(indx1)), rep("hr6", length(indx2))),
                 log2_NFKBIA=c(hr2, hr4))
library(ggplot2)
setwd("~/__Data")
pdf("LoupeCluster6Bcells.Violin4Hr6Hr_NFKBIA.pdf")
ggplot(DF, aes(x=Time, y=log2_NFKBIA)) + 
  geom_violin(fill=rgb(0,0.5,1,0.15)) +
  geom_boxplot(width=0.1, color="darkred") +
  stat_summary(fun.y=median, geom="point", size=2, color="red")
dev.off()

# library(foreach)
# library(doParallel)
# HPC <- makeCluster(64)
# registerDoParallel(HPC)
# 
# j <- dim(normalizedPBMC)[1]
# foreach (i = 1:j) %dopar% {
#   print(i)
#   x <- as.vector(normalizedPBMC[i, ])
#   testDE(x)
# }


setwd("~/__Data"); getwd()
clusters <- read.csv("clusters.csv", as.is=TRUE)
clusterIDs <- unlist(lapply(strsplit(clusters$Barcode, "-"), function(x) x[1]))
clusters <- clusters[match(PBMC.IDs, clusterIDs), ]

IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")
CLs = 1:10

Sys.time()
avExpList <- list(); indx = 0
for (i in IDs) {
  print(i)
  i.ID <- grep(i, colnames(normalizedPBMC))
  for (cl in CLs) {
     i.CL <- grep(cl, clusters$Cluster)
     resMtrx = colID = NULL
     for (h in HRs) {
          i.HR <- grep(h, colnames(normalizedPBMC))
          j <- intersect(intersect(i.ID, i.HR), i.CL)
          if (length(j) > 2) { # skip clusters with few cells in this ID+HR
            resMtrx <- cbind(resMtrx, apply(normalizedPBMC[ , j], 1, median))
            colID <- c(colID, paste0(i, ":", "C", cl, ":", h))
          }
     }
     if (!is.null(resMtrx)) {
       colnames(resMtrx) <- colID
       indx <- indx + 1
       avExpList[[indx]] <- resMtrx
       names(avExpList)[indx] <- paste0(i, ":", "C", cl)
     }
  }
}
Sys.time()

selGenes <- lapply(avExpList, 
                   function(x) which(unlist(apply(x, 1, max)) > 1))
for (i in 1:length(selGenes)) {
  avExpList[[i]] <- avExpList[[i]][selGenes[[i]], ]
}

setwd("~/__Data"); getwd()
save(avExpList, file="avExpList.RData")

library(Hmisc)
corrList <- lapply(avExpList, function(x) {
                  if (ncol(x) > 4) rcorr(t(x)) 
                  })
names(corrList)[lapply(corrList, length) == 0] # "BRISL2:C5" "BRISL2:C7"
corrList <- corrList[lapply(corrList, length) > 0]
setwd("~/__Data"); getwd()
# save(corrList, file="corrList.RData")
corrList <- get(load("corrList.RData"))

library(corrplot)
setwd("~/__Data"); getwd()
pdf("shelfLifeCorrPlots.pdf")
for (i in 1:length(corrList)) {
    x <- corrList[[i]]
    if (length(x) > 0) {
        x$P[which(is.na(x$P))] <- 1
        x$r[which(is.na(x$r))] <- 0
        x$r[x$r < -1 | x$r > 1] <- 0
        myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988", 
                              "#FFFFFF", "#77AADD", "#4477AA")))
        corrplot(x$r, type="upper", order="hclust", method="color",
                 p.mat = x$P, sig.level = 0.01, insig = "blank", 
                 col=myColors(200), diag=FALSE, tl.col="black", 
                 tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
                 mar = c(1, 1, 1, 1), hclust.method="complete")
    }
}
dev.off()

coExpMtrx = NULL
for (i in 1:length(corrList)) {
  x <- corrList[[i]]
  # Filter out unreliable P's:
  x$P[which(is.na(x$P))] <- 1
  x$P[which(is.nan(x$P))] <- 1
  x$P[which(is.na(x$r))] <- 1
  x$P[x$r < 0 | x$r > 1] <- 1
  coExpCount <- apply(x$P, 1, function(Y) length(which(Y < 0.01)))
  coExpMtrx <- rbind(coExpMtrx, coExpCount)
}
rownames(coExpMtrx) <- names(corrList)

library(pheatmap)
selGenes <- names(which(corrList[[3]]$P["CDC42", ] == 0))
mtrx <- avExpList[[names(corrList)[3]]][selGenes, ]
mtrx <- t(apply(mtrx, 1, scale))
colnames(mtrx) <- colnames(avExpList[[names(corrList)[3]]])
setwd("~/__Data"); getwd()
pdf("BRISL2.LoupeC3.corrCDC42.heatmap.pdf")
pheatmap(mtrx, cluster_cols=FALSE)
dev.off()

X <- avExpList[[names(corrList)[3]]][selGenes, ]
maxY <- max(X)
plot(c(1,5), c(0,maxY))
for (i in selGenes) {
  lines(X[i, ], col=rgb(0,0,0,0.25))
}


#### Correlation across all 3 donors:
setwd("~/__Data")
pdf("corrPlot_allClusters_allSamples.pdf")
for (cl in 1:10) {
  Q <- paste0(":C", cl, "$")
  subList <- avExpList[grep(Q, names(avExpList))]
  geneList <- lapply(subList, rownames)
  shared <- table(do.call(c, geneList))
  shared <- names(shared)[shared == 3]
  subList <- lapply(subList, function(x) x[shared, ])
  clusterExp <- do.call(cbind, subList)
  
  library(Hmisc)
  clusterCorr <- rcorr(t(clusterExp))
  
  corrMtrx <- clusterCorr$r
  corrMtrx[corrMtrx > 1] <- 0
  library(corrplot)
  myColors <- colorRampPalette(rev(c("#BB4444", "#EE9988",
  "#FFFFFF", "#77AADD", "#4477AA")))
  corrplot(corrMtrx, type="upper", order="hclust", method="color",
          p.mat = x$P, sig.level = 0.05, insig = "blank",
          col=myColors(200), diag=FALSE, tl.col="black",
          tl.srt=45, title=names(corrList[i]), tl.cex=0.1,
          mar = c(1, 1, 1, 1), hclust.method="ward.D2", main=
          paste0("Loupe Cell Type Cluster ", cl))
  }
dev.off()

# Ps <- clusterCorr$P
# Ps[lower.tri(Ps, diag=TRUE)] <- NA
# Ps[(Ps > 0.01) | is.na(Ps) | is.nan(Ps)] <- 0
# Ps[Ps < 0.01 & Ps > 0] <- 1
# corrMtrx <- corrMtrx * Ps
# library(pheatmap)
# setwd("~/__Data")
# pdf("corrHeatmap_LoupeC1_allSamples.pdf")
# pheatmap(corrMtrx, clustering_method="ward.D2", fontsize_row=2, fontsize_col=2)
# dev.off()

# # For each donor, take median expression per gene per timepoint
# library(foreach)
# library(doParallel)
# HPC <- makeCluster(64)
# registerDoParallel(HPC)
# donor = avExp = NULL
# avExp <- foreach(ID = c("BRISL3", "BRISL4"), 
#                  hr = c("1h", "2h"), 
#                  CL = 1:3, 
#                  .combine = "rbind", .verbose = TRUE) %dopar% { 
#   indx <-  which(clusters$Cluster == CL)
#   cellType <- as.matrix(normalizedPBMC[ , indx])
#   donor <- cellType[ , grep(ID, colnames(cellType))]
#   donor <- apply(donor, 2, function(x) log2(x + 1))
#   selCols <- grep(hr, colnames(donor))
#   apply(donor[ , selCols], 1, median)
# }
# setwd("~/__Data"); getwd()
# save(avExp, file="avExpPerDonorPerTimepoint.RData")
```


```{r mFuzzCLustering}

setwd("~/__Data"); getwd()
avExpList <- get(load("avExpList.RData"))

library(Mfuzz)
setwd("~/__Data")
pdf('mfuzzClusters.pdf')
allClusters = list()
for (i in 1:length(avExpList)) {
  eset <- ExpressionSet(avExpList[[i]])
  eset <- filter.std(eset, min.std = 0.1, visu = FALSE) 
  M <- mestimate(eset); M
  eset <- standardise(eset)
  cl <- mfuzz(eset, c=4, m=M)
  allClusters[[i]] <- cl
  shortName <- gsub("BRISL|C", "", names(avExpList)[i])
  tLabels <- paste0(shortName, ":", 
                    c("2", "4", "6", "8", "18")[1:ncol(avExpList[[i]])])
  # mfuzz.plot(eset, cl=cl, mfrow=c(2, 2), new.window=FALSE,
  # 		   time.labels=tLabels,
  # 		   min.mem=0.5) 
}
dev.off()
names(allClusters) <- names(avExpList)
setwd("~/__Data")
# save(allClusters, file="all.mFuzz.clusters.RData")
allClusters <- get(load("all.mFuzz.clusters.RData"))

selCL <- allClusters[[1]][[3]]
selGenes <- names(selCL[selCL == 4])

X <- avExpList[[names(allClusters)]][selGenes, ]
maxY <- max(X)
setwd("~/__Data")
pdf("BRISL2.LoupeC1.mFuzzCluster4_timeCourse.pdf")
plot(c(1,5), c(0,maxY), col=rgb(1,1,1,0), xaxt="n", 
     xlab="timepoint", ylab="Normalized log2 expression")
axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
for (i in 1:length(selGenes)) {
  lines(X[selGenes[i], ], col=i) # rgb(0,0,0,0.25)
}
dev.off()

# Get cluster member genes for visually identified up in 4-6 hours clsuters:
# BRISL2:C6   mFuzz cluster 1
# BRISL3:C6   mFuzz cluster 1
# BRISL4:C6   mFuzz cluster 2
B2C6 <- names(which(allClusters[["BRISL2:C6"]]["cluster"][[1]] == 1))
B3C6 <- names(which(allClusters[["BRISL3:C6"]]["cluster"][[1]] == 1))
B4C6 <- names(which(allClusters[["BRISL4:C6"]]["cluster"][[1]] == 2))
# intersect(intersect(B2C6, B3C6), B4C6) # empty
# sort(table(c(B2C6, B3C6, B4C6))) # REL == 2, IRF1 == 2

B2C7.1 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 1))
B2C7.4 <- names(which(allClusters[["BRISL2:C7"]]["cluster"][[1]] == 4))
B3C7 <- names(which(allClusters[["BRISL3:C7"]]["cluster"][[1]] == 4))
B4C7 <- names(which(allClusters[["BRISL4:C7"]]["cluster"][[1]] == 3))
B2 <- unique(c(B2C7.1, B2C7.4))
sort(intersect(intersect(B2, B3C7), B4C7))
# "NACA"  "RPL31" "RPL35" "RPL36" "RPS19" "RPS21" "RPS26" "RPS29" "SRP14" "SUB1"
# The 7 RPL/RPS genes are involved in Ag presentation (as well as protein translation)

# pDCs == loupe cluster 10
B2C10 <- names(which(allClusters[["BRISL2:C10"]]["cluster"][[1]] == 2))
B3C10.1 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 1))
B3C10.2 <- names(which(allClusters[["BRISL3:C10"]]["cluster"][[1]] == 2))
B4C10.2 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 2))
B4C10.4 <- names(which(allClusters[["BRISL4:C10"]]["cluster"][[1]] == 4))
B3 <- unique(c(B3C10.1, B3C10.2))
B4 <- unique(c(B4C10.2, B4C10.4))
rev(sort(table(c(B2C10, B3, B4))))
# TRIR                   SPCS3                   SNRPB                  SEC11C 
#    3                       3                       3                       3
# TargetMine: cellular nitrogen compound metabolic process [GO:0034641]
# All 4 genes are associated with cd123+ plasmacytoid dcs 	BH-adjP=0.0175 

# Plot timecourse of AvExp of above 4 genes:
IDs = c("BRISL2", "BRISL3", "BRISL4")
HRs = c("2h", "4h", "6h", "8h", "18h")
# genes.pDC <- c("TRIR","SPCS3", "SNRPB","SEC11C")
genes.pDC <- c("NACA","RPL31","RPL35","RPL36","RPS19","RPS21","RPS26","RPS29","SRP14","SUB1")
myColors <- c("cyan", "forestgreen", "red") 

setwd("~/__Data")
pdf("LoupeCluster7_genesAfftedAt4to6Hours_timeCourse.pdf")
par(mfrow=c(2,2))
for (g in genes.pDC) {
  expVals = NULL
  for (ID in IDs){
    expVals <- c(expVals, avExpList[[paste0(ID, ":C10")]][g, ])
  }
  MAX <- max(expVals)
  MIN <- min(expVals)
  plot(c(1, 5), c(MIN, MAX), xaxt='n', xlab="timepoint", 
       ylab="log2(normReads+1)", col="white", main=paste0(g))
  axis(side=1, at=c(1:5), labels=c("2h", "4h", "6h", "8h", "18h"))
  for (i in 1:length(IDs)) {
    vals <- avExpList[[paste0(IDs[i], ":C10")]][g, ]
    lines(1:5, vals, col=myColors[i], type='b')
  }
}
dev.off()

# Cluster 7 (unknown cell type!) genes:


```

### PCA. Note using only most variable features.

```{r pca,results='hide'}
pbmc <- RunPCA(object = pbmc, features = VariableFeatures(object = pbmc))
# names(pbmc) #  "RNA" "SCT" "pca"
# pbmc[['pca']]@feature.loadings[1:5,1:5] 
```

```{r pca_viz, message=TRUE}
# Examine and visualize PCA results a few different ways
print(x = pbmc[['pca']], dims = 1:5, nfeatures = 5)
VizDimLoadings(object = pbmc, dims = 1:2, reduction = 'pca')
DimPlot(object = pbmc, reduction = 'pca')
```

`DimHeatmap` can be useful when deciding which PCs to include. Cells and features are ordered according to their PCA scores. `cells` = 'a number' plots the 'extreme' cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. 

```{r single-heatmap}
DimHeatmap(object = pbmc, dims = 1, cells = 500, balanced = TRUE)
```

```{r multi-heatmap, fig.height=12, fig.width=9}
DimHeatmap(object = pbmc, dims = 1:15, cells = 500, balanced = TRUE)
```

### Determine the 'dimensionality' of the dataset

JackStraw == randomly permute a subset of the data (1% by default) and rerun PCA, constructing a 'null distribution' of feature scores, and identify 'significant' PCs by comparing the distribution of p-values for each PC vs. a uniform distribution (dashed line). 'Significant' PCs will show a solid curve above the dashed line.

```{r jackstraw, fig.height=6, fig.width=10}
# NOTE: SLOW, comment out and use ElbowPlot()
# pbmc <- JackStraw(object = pbmc, num.replicate = 100)
# pbmc <- ScoreJackStraw(object = pbmc, dims = 1:20)
```

# Use elbow plot instead:

```{r elbow_plot, fig.height=6, fig.width=10}
ElbowPlot(object = pbmc)
```

# choose 10 here, but :

* Dendritic cell and NK aficionados may recognize that genes strongly associated with PCs 12 and 13 define rare immune subsets 
* err on the higher side.

### Cluster the cells

See [[SNN-Cliq, Xu and Su, Bioinformatics, 2015]](http://bioinformatics.oxfordjournals.org/content/early/2015/02/10/bioinformatics.btv088.abstract) and CyTOF data [[PhenoGraph, Levine *et al*., Cell, 2015]](http://www.ncbi.nlm.nih.gov/pubmed/26095251). 

To cluster the cells, can use the Louvain algorithm (default) or SLM [[SLM, Blondel *et al*., Journal of Statistical Mechanics]](http://dx.doi.org/10.1088/1742-5468/2008/10/P10008) via `FindClusters`.

A resolution parameter sets the 'granularity' of the downstream clustering (larger values, more clusters) ~ typical range 0.4-1.2 

The clusters can be found using the `Idents` function.


```{r cluster, fig.height=5, fig.width=7}
pbmc <- FindNeighbors(object = pbmc, dims = 1:10)
pbmc <- FindClusters(object = pbmc, resolution = 0.5)

# Assigned cluster numbers:     
clusterIDs <- Idents(object = pbmc)
# table(clusterIDs) # Note: getting a 14-cell tenth cluster!
#   0   1   2   3   4   5   6   7   8   9 
# 654 443 365 347 273 206 157 146  33  14 
```

### Run non-linear dimensional reduction (UMAP/tSNE)

Use the same PCs as input to the clustering analysis.

```{r tsne, fig.height=5, fig.width=7}
# Install UMAP, via pip or reticulate::py_install(packages = "umap-learn")
pbmc <- RunUMAP(object = pbmc, dims = 1:10)
# Coords of UMMAP plot are in     pbmc[['umap']]@cell.embeddings
```

```{r tsneplot, fig.height=5, fig.width=7}
# Set `label = TRUE` or use the LabelClusters function for labeling
DimPlot(object = pbmc, reduction = 'umap', label = TRUE)
```

```{r saveobject, eval=FALSE}
# saveRDS(pbmc, file = "~/Desktop/filtered_gene_bc_matrices/pbmc_tutorial.rds")
```

Finding differentially expressed features (cluster biomarkers)
`min.pct`  
`max.cells.per.ident`  will downsample each identity class to save time.

```{r markerAnalysis, fig.height=8, fig.width=15}
# find all markers of cluster 1
#cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
#head(x = cluster1.markers, n = 5)

# find all markers distinguishing cluster 5 from clusters 0 and 3
# cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(x = cluster5.markers, n = 5)

###################################################################################
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC) # top 2 +ve FC markers per cluster
save(pbmc.markers, file="pbmc3k_markers.RData")


#################### HB: marker gene enrichment analysis ##########################

pbmc_3k_clusters <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", 
                       "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk", "blob")

# 1) Over-representation:

library(clusterProfiler)
library(gage)
library(pathview)

markersList <- split(rownames(pbmc.markers), pbmc.markers$cluster)

keggPathways = NULL
for (i in 1:length(markersList)) {
  markerEGs <- id2eg(markersList[[i]])[ ,'ENTREZID']
  markerEGs <- markerEGs[!is.na(markerEGs)]

  keggE <- enrichKEGG(gene = markerEGs, organism = 'hsa', pvalueCutoff = 1) # NB p = 1

  indx <- which(keggE$qvalue < 0.05)
  if (length(indx > 0)) {
    iPathways <- data.frame(clusterNo=i, publishedLabel=pbmc_3k_clusters[i],
                            pathway=keggE$Description[indx],
                            pValue=keggE$qvalue[indx])
    keggPathways <- rbind(keggPathways, iPathways)
  }
  print(i)
}
save(keggPathways, file="keggPathways_pbmc3k.RData")

# 2) GSEA:

orderedMarkers <- pbmc.markers[order(pbmc.markers$avg_logFC, decreasing=TRUE), ]
markerListGSEA <- split(pbmc.markers$avg_logFC, pbmc.markers$cluster)
IDs <- split(pbmc.markers[ ,"gene"], pbmc.markers$cluster)
for (i in 1:length(markerListGSEA)) {
  names(markerListGSEA[[i]]) <- IDs[[i]]
}

resGSEA = NULL
for (i in 1:length(markerListGSEA)) {
  egIDs <- id2eg(names(markerListGSEA[[i]]))
  markersGSEA <- markersGSEA[!is.na(egIDs)]
  names(markersGSEA) <- egIDs[!is.na(egIDs)]
  markersGSEA <- rev(sort(markersGSEA))
  res <- gseKEGG(geneList = markersGSEA, organism = 'hsa', nPerm = 1000, 
                 minGSSize = 1, pvalueCutoff = 0.05, verbose = FALSE) # NB minGS = 1
  if (length(res$ID) > 0) {
    resDF <- data.frame(clusterNo=i, publishedLabel=pbmc_3k_clusters[i],
                        pathway=res$Description, pValue=res$qvalues)
    resGSEA <- rbind(resGSEA, resDF)
  }
}
save(resGSEA, file="keggGSEA_pbmc3k.RData")


################## HB: Testing correlation to published signaturs ###################

# 1) Signatures from CellMix
# install.packages('CellMix', repos = 'http://web.cbio.uct.ac.za/~renaud/CRAN', type='both')
library(CellMix)
# haem <- MarkerList("HaemAtlas") # need to convert probe IDs to gene symbols
# abbas <- MarkerList("Abbas")    # need to convert probe IDs to gene symbols

#############################################################################################
# 2) Markers from publications
# NOT USE: Markers are not unique to cell types
# read.delim("immuneMarkersTblHB.txt", header=TRUE)

sigsDir <- "/Users/hamid.bolouri/Dropbox/__AIImm/__dataPBMC/__Signatures/"
# sigsDir <- "/Users/H/Desktop/Dropbox/__AIImm/__dataPBMC/__Signatures/"
# Angelova = PMID:25853550
angelova <- read.csv(paste0(sigsDir, "angelova-2015-cellmatrix.csv"), 
                     as.is=TRUE, row.names=1)
cancerImm <- read.delim(paste0(sigsDir, "immuneMarkersInSolidCancers_PMID28052254.txt"), 
                        header=TRUE, row.names=1)
nanostring <- read.delim(paste0(sigsDir, "nanoStringImmuneCellMarkers.txt"), 
                         header=TRUE) 

#cellTypeGenes <- split(angelova$gene, angelova$cell)
# cellTypeGenes <- split(nanostring$gene, nanostring$cellType) 
cellTypeGenes <- split(rownames(cancerImm), cancerImm$CellType) 
total <- 22000; cellTypeRes = NULL
for (i in 1:length(markersList)) {
  for (j in 1:length(cellTypeGenes)) {
    set1 <- markersList[[i]]
    nSet1 <- length(set1)
    set2 <- cellTypeGenes[[j]]
    nSet2 <- length(set2)
    nOverlap <- length(intersect(set1, set2))
    cellID <- names(cellTypeGenes)[j]
    P <- 1 - phyper(nOverlap -1, nSet1, (total-nSet1), nSet2)
    if (P < 0.05) {
      resDF <- data.frame(clusterNo=i, publishedLabel=pbmc_3k_clusters[i],
                          cellType=cellID, adj.p=P * (i*j))
      cellTypeRes <- rbind(cellTypeRes, resDF)
    }
  }
}
# save(cellTypeRes, file="cellTypeRes_Angelova.RData")
# save(cellTypeRes, file="cellTypeRes_NanoString.RData")
save(cellTypeRes, file="cellTypeRes_cancerImm.RData")

###############################################################################################
# 3) Classifier genes from publications:
LM22 <- read.delim(paste0(sigsDir, "CIBERSORT_LM22.txt"), as.is=TRUE, header=TRUE, row.names=1)
GSE107011 <- read.csv(paste0(sigsDir, "PBMC_17of_29CellTypesRNAseqSignatures.csv"), 
                      header=TRUE, row.names=1, as.is=TRUE) # 17 cell types
pmid30413720 <- read.csv(paste0(sigsDir, 'immunoStates_320Genes20CellTypes_signature.csv'),
                         skip=2, header=TRUE, row.names=1, as.is=TRUE) # 20 cell types

pbmc_3k_clusters <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", 
                       "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk", "blob")

library(Hmisc)
library(lsa)

classSig <- pmid30413720 # LM22 # GSE107011 # pmid30413720
i = 0; typesTbl = NULL
for (iClust in levels(clusterIDs)) {
  i = i + 1
  j <- which(clusterIDs == iClust)
  sharedGenes <- intersect(rownames(normalizedPBMC), rownames(classSig))
  clustCentroid <- apply(as.matrix(normalizedPBMC[sharedGenes, j]), 1, median)
  
  corrMtrx <- rcorr(clustCentroid, as.matrix(classSig[sharedGenes, ]), type="pearson")
  iGood <- which(corrMtrx$P[1, ] < 0.05)
  
  cosineSim <- cosine(cbind(clustCentroid, as.matrix(classSig[sharedGenes, ])))
  cosineSim <- cosineSim[1, ]
  
  res <- data.frame(corr=corrMtrx$r[1, ], cosineSim=cosineSim, 
                    clusterNo=iClust, publishedLabel=pbmc_3k_clusters[i],
                    signature=c("", colnames(classSig)))
  res <- res[rev(order(res$corr, res$cosineSim)), ]
  typesTbl <- rbind(typesTbl, res)
}
typesTbl <- typesTbl[!grepl("^x", rownames(typesTbl)), ]
rownames(typesTbl) <- NULL
#save(typesTbl, file="/ellTypeTbl_LM22.RData")
# save(typesTbl, file=c"ellTypeTbl_GSE107011.RData")
save(typesTbl, file="cellTypeTbl_pmid30413720.RData")

#######################################################################################################
# 4) celaref:
library(celaref)
# pbmc.markers$avg_logFC, pbmc.markers$gene
cellInfoTbl <- data.frame(cellId=names(clusterIDs), Sample="blank" , Cluster=clusterIDs, group="group")
dataset_se <- load_se_from_tables(counts_matrix = normalizedPBMC,
                                  cell_info_table = cellInfoTbl, 
                                  group_col_name  = "group")
dataset_se <- trim_small_groups_and_low_expression_genes(dataset_se, 
                                    min_lib_size = 100, # set low to keep all cells!
                                    min_group_membership = 5,  
                                    min_detected_by_min_samples = 5)
# Count and store total reads/gene.
# rowData(dataset_se)$total_count <- Matrix::rowSums(assay(dataset_se))
# rowData(dataset_se)$GeneSymbol <- rownames(assay(dataset_se))
# colData(dataset_se)$ID <- as.character(colData(dataset_se)$cellId)
# rowData(dataset_se) must already list column 'GeneSymbol'
# dataset_se <- convert_se_gene_ids(dataset_se, new_id='GeneSymbol', eval_col='total_count')
# dataset_se.filtered <- trim_small_groups_and_low_expression_genes(demo_query_se)

library(ExperimentHub)
eh = ExperimentHub()
de_table.Watkins2009PBMCs <- ExperimentHub::loadResources(eh, "celarefData", 'de_table_Watkins2009_pbmcs')[[1]]

library(parallel)
de_table_query <- contrast_each_group_to_the_rest(dataset_se, "PBMC3K", num_cores = 4)

#########################################################################################################
# 5) SCDE/PAGODA
library(scde)
data(pollen)
# remove poor cells and genes
tmp <- as.matrix(normalizedPBMC)
# CD <- clean.counts(tmp) # produces an empty matrix 
tmp <- apply(tmp ,2, function(x) {storage.mode(x) <- 'integer'; x})
knn <- knn.error.models(normalizedPBMC, k = ncol(cd)/4, n.cores = 4, min.count.threshold = 2, min.nonfailed = 5, max.model.plots = 10)

```

see  [DE vignette](http://satijalab01.nygenome.org/seurat/v3.0/de_vignette.html) for more DE methods.

```{r markersroc, fig.height=8, fig.width=15}
# cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
```

`VlnPlot` == probability distributions across clusters)
`FeaturePlot` == feature expression on a tSNE or PCA plot)
See also `RidgePlot`, `CellScatter`, and `DotPlot`.

```{r markerplots, fig.height=8, fig.width=15}
VlnPlot(object = pbmc, features = c("MS4A1", "CD79A"))
# raw counts:
VlnPlot(object = pbmc, features = c("NKG7", "PF4"), slot = 'counts', log = TRUE)
FeaturePlot(object = pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A"))
```

`DoHeatmap` generates an expression heatmap for given cells and features. In this case, we are plotting the top 20 markers (or all markers if less than 20) for each cluster.

```{r clusterHeatmap, fig.height=8, fig.width=15}
pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC) -> top10
DoHeatmap(object = pbmc, features = top10$gene) + NoLegend()
```

### Assigning cell type identity to clusters

canonical markers of cell types for this example:

Cluster ID | Markers       | Cell Type
-----------|---------------|----------
0          | IL7R, CCR7    | Memory CD4+ 
1          | CD14, LYZ     | CD14+ Mono
2          | IL7R, S100A4  | Naive CD4+ T 
3          | MS4A1         | B 
4          | CD8A          | CD8+ T 
5          | FCGR3A, MS4A7 | FCGR3A+ Mono
6          | GNLY, NKG7    | NK 
7          | FCER1A, CST3  | DC
8          | PPBP          | Mk


```{r labelplot, fig.height=5, fig.width=9}
new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Mk", "blob")
names(x = new.cluster.ids) <- levels(x = pbmc)
pbmc <- RenameIdents(object = pbmc, new.cluster.ids)
DimPlot(object = pbmc, reduction = 'umap', label = TRUE, pt.size = 0.5) + NoLegend()
```

```{r save.img, include=FALSE}
# library(ggplot2)
# plot <- DimPlot(object = pbmc, reduction = "umap", label = TRUE, label.size = 4.5) + xlab("UMAP 1") + ylab("UMAP 2") + 
#   theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + 
 #  guides(colour = guide_legend(override.aes = list(size = 10)))
# ggsave(filename = "~/Desktop/filtered_gene_bc_matrices/hg19/pbmc3k_umap.png", height = 7, width = 12, plot = plot)
```

```{r save.rds}
# saveRDS(pbmc, file = "~/Desktop/filtered_gene_bc_matrices/hg19/pbmc3k_final.rds")
```

```{r etc}
# First, in the "Compute engine console", use the SSH button to bring up a shell and install these:
sudo apt-get install libcurl4-openssl-dev
sudo apt-get install libssl-dev

# Then in R, run:
install.packages('Seurat', repos="https://cloud.r-project.org")
install.packages("liger")
linstall.packages("knitr")

````
